name: KAS Build CI

on:
  push:
    branches: [ main, develop ]
    paths:
      - 'recipes-**'
      - 'conf/**'
      - 'kas/**'
      - 'scripts/**'
      - 'classes/**'
      - '.github/workflows/kas-build-ci.yml'
  pull_request:
    branches: [ main, develop ]
    paths:
      - 'recipes-**'
      - 'conf/**'
      - 'kas/**'
      - 'scripts/**'
      - 'classes/**'
      - '.github/workflows/kas-build-ci.yml'
  workflow_dispatch:
    inputs:
      machine:
        description: 'Specific machine to build (optional - builds all active machines if not specified)'
        required: false
        type: choice
        options:
          - 'all'
          - 'imx8mm-jaguar-sentai'
          - 'imx93-jaguar-eink'
          # Temporarily disabled:
          # - 'imx8mm-jaguar-inst'
          # - 'imx8mm-jaguar-phasora'
          # - 'imx8mm-jaguar-handheld'

        default: 'all'

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # Job to determine which machines to build
  setup:
    runs-on: self-hosted
    outputs:
      machines: ${{ steps.machines.outputs.machines }}
      should_build: ${{ steps.changes.outputs.should_build }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check for relevant changes
        id: changes
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "should_build=true" >> $GITHUB_OUTPUT
          elif [ "${{ github.event_name }}" = "push" ] && [ "${{ github.ref }}" = "refs/heads/main" ]; then
            echo "should_build=true" >> $GITHUB_OUTPUT
          elif [ "${{ github.event_name }}" = "pull_request" ]; then
            # For PRs, check if any relevant files changed
            if git diff --name-only origin/main...HEAD | grep -E '^(recipes-|conf/|kas/|scripts/|classes/)'; then
              echo "should_build=true" >> $GITHUB_OUTPUT
            else
              echo "should_build=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "should_build=false" >> $GITHUB_OUTPUT
          fi

      - name: Determine machines to build
        id: machines
        run: |
          if [ "${{ github.event.inputs.machine }}" != "" ] && [ "${{ github.event.inputs.machine }}" != "all" ]; then
            echo "machines=[\"${{ github.event.inputs.machine }}\"]" >> $GITHUB_OUTPUT
          else
            # Temporarily disabled: imx8mm-jaguar-inst, imx8mm-jaguar-phasora, imx8mm-jaguar-handheld
            echo 'machines=["imx8mm-jaguar-sentai","imx93-jaguar-eink"]' >> $GITHUB_OUTPUT
          fi

  # Validation job - quick checks before expensive builds
  validate:
    runs-on: self-hosted
    needs: setup
    if: needs.setup.outputs.should_build == 'true'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Docker for validation
        run: |
          # We'll use Docker containers for all operations, including validation
          # This avoids installing tools on the host runner
          echo "ðŸ³ Using Docker containers for validation and builds"
          
          # Verify Docker is available
          if ! command -v docker >/dev/null 2>&1; then
            echo "âŒ Docker not available on self-hosted runner"
            exit 1
          fi
          
          echo "âœ… Docker is available"
          docker --version

      - name: Validate KAS configurations
        run: |
          echo "ðŸ” Validating KAS configuration files..."
          
          # Check if required KAS files exist
          required_files=(
            "kas/lmp-dynamicdevices-base.yml"
            "kas/lmp-dynamicdevices-mfgtool.yml"
            "kas/base.yml"
            "kas/bsp.yml"
            "kas/dynamicdevices.yml"
          )
          
          for file in "${required_files[@]}"; do
            if [ ! -f "$file" ]; then
              echo "âŒ Missing required KAS file: $file"
              exit 1
            else
              echo "âœ… Found: $file"
            fi
          done

      - name: Validate machine configurations
        run: |
          echo "ðŸ” Validating machine configuration files..."
          
          machines='${{ needs.setup.outputs.machines }}'
          echo "Machines to validate: $machines"
          
          # Parse JSON manually to avoid Docker complexity in validation
          # Extract machine names from JSON array format like ["machine1","machine2"]
          machine_list=$(echo "$machines" | sed 's/\[//g' | sed 's/\]//g' | sed 's/"//g' | tr ',' '\n')
          
          for machine in $machine_list; do
            # Trim whitespace
            machine=$(echo "$machine" | xargs)
            if [ -n "$machine" ]; then
              conf_file="conf/machine/${machine}.conf"
              if [ ! -f "$conf_file" ]; then
                echo "âŒ Missing machine config: $conf_file"
                exit 1
              else
                echo "âœ… Found machine config: $conf_file"
              fi
            fi
          done

      - name: Lint scripts
        run: |
          echo "ðŸ” Linting shell scripts with Docker..."
          
          # Use shellcheck via Docker container (no host installation needed)
          if find scripts/ -name "*.sh" -print -quit | grep -q .; then
            echo "Running shellcheck on shell scripts..."
            # Run shellcheck on each script individually to avoid path issues
            find scripts/ -name "*.sh" -exec bash -c 'docker run --rm -v "$PWD:/mnt" koalaman/shellcheck:stable "/mnt/$1"' _ {} \;
          else
            echo "âš ï¸ No shell scripts found to lint"
          fi

      - name: Validate Yocto recipes
        run: |
          echo "ðŸ” Validating Yocto recipes and configurations..."
          
          # Check for common Yocto recipe issues
          echo "Checking for recipe syntax issues..."
          
          # Check .bb and .bbappend files for common issues
          find recipes* bbappends* conf/ -name "*.bb" -o -name "*.bbappend" -o -name "*.conf" | while read -r file; do
            echo "Checking: $file"
            
            # Check for common syntax issues
            if grep -n "^[[:space:]]*=" "$file" >/dev/null 2>&1; then
              echo "âš ï¸  Potential assignment issue in $file (line starts with whitespace + =)"
              grep -n "^[[:space:]]*=" "$file" || true
            fi
            
            # Check for tabs vs spaces consistency
            if grep -P "\t" "$file" >/dev/null 2>&1 && grep "^    " "$file" >/dev/null 2>&1; then
              echo "âš ï¸  Mixed tabs and spaces in $file"
            fi
            
            # Check for trailing whitespace
            if grep -n "[[:space:]]$" "$file" >/dev/null 2>&1; then
              echo "âš ï¸  Trailing whitespace in $file"
              grep -n "[[:space:]]$" "$file" | head -5 || true
            fi
            
            # Check for proper SRC_URI format
            if grep -n "SRC_URI.*=" "$file" | grep -v "file://" | grep -v "git://" | grep -v "https://" | grep -v "http://" | grep -v "ftp://" >/dev/null 2>&1; then
              echo "âš ï¸  Potential SRC_URI format issue in $file"
            fi
          done
          
          echo "âœ… Yocto recipe validation complete"

      - name: Check layer compatibility
        run: |
          echo "ðŸ” Checking layer compatibility and dependencies..."
          
          # Validate layer.conf files
          find . -name "layer.conf" | while read -r layerconf; do
            echo "Validating layer config: $layerconf"
            
            # Check for required variables
            for var in BBPATH BBFILES BBFILE_COLLECTIONS; do
              if ! grep -q "^$var" "$layerconf"; then
                echo "âš ï¸  Missing $var in $layerconf"
              fi
            done
            
            # Check for proper priority setting
            if ! grep -q "BBFILE_PRIORITY" "$layerconf"; then
              echo "âš ï¸  Missing BBFILE_PRIORITY in $layerconf"
            fi
          done
          
          # Check for circular dependencies in .bb files
          echo "Checking for potential circular dependencies..."
          find recipes* bbappends* -name "*.bb" -o -name "*.bbappend" | while read -r recipe; do
            # Extract package name from filename
            pkg_name=$(basename "$recipe" | sed 's/_.*\.bb.*//')
            
            # Check if package depends on itself
            if grep -q "DEPENDS.*$pkg_name" "$recipe" 2>/dev/null; then
              echo "âš ï¸  Potential circular dependency in $recipe"
            fi
          done
          
          echo "âœ… Layer compatibility check complete"

      - name: Validate device tree syntax
        run: |
          echo "ðŸ” Validating device tree files..."
          
          # Check .dts files for common issues
          find . -name "*.dts" -o -name "*.dtsi" | while read -r dtfile; do
            echo "Checking device tree: $dtfile"
            
            # Check for proper node naming
            if grep -n "[^a-zA-Z0-9_-]@[^0-9a-fA-F]" "$dtfile" >/dev/null 2>&1; then
              echo "âš ï¸  Invalid node naming in $dtfile"
            fi
            
            # Check for missing semicolons
            if grep -n "^\s*[a-zA-Z_-].*=" "$dtfile" | grep -v ";" >/dev/null 2>&1; then
              echo "âš ï¸  Potential missing semicolon in $dtfile"
              grep -n "^\s*[a-zA-Z_-].*=" "$dtfile" | grep -v ";" | head -3 || true
            fi
            
            # Check for proper indentation consistency
            if grep -P "^\t" "$dtfile" >/dev/null 2>&1 && grep "^    " "$dtfile" >/dev/null 2>&1; then
              echo "âš ï¸  Mixed tabs and spaces indentation in $dtfile"
            fi
          done
          
          echo "âœ… Device tree validation complete"

      - name: CVE and security scanning
        run: |
          echo "ðŸ”’ Running CVE and security vulnerability scanning..."
          
          # Check for known vulnerable packages in recipes
          echo "Scanning for known vulnerable package versions..."
          
          # Common vulnerable packages to check
          vulnerable_packages=(
            "openssl"
            "glibc" 
            "busybox"
            "dropbear"
            "openssh"
            "curl"
            "wget"
            "zlib"
            "libpng"
            "libjpeg"
            "expat"
            "libxml2"
            "pcre"
            "sqlite3"
            "python3"
            "nodejs"
            "nginx"
            "apache2"
            "bind"
            "dnsmasq"
            "hostapd"
            "wpa-supplicant"
            "bluez5"
            "avahi"
            "systemd"
            "udev"
            "kernel"
            "u-boot"
          )
          
          # Check for hardcoded versions that might be vulnerable
          for pkg in "${vulnerable_packages[@]}"; do
            # Look for version pinning in recipes
            if find recipes* bbappends* conf/ -name "*.bb" -o -name "*.bbappend" -o -name "*.inc" | xargs grep -l "$pkg" 2>/dev/null; then
              echo "ðŸ“‹ Found references to security-sensitive package: $pkg"
              
              # Check for version specifications
              find recipes* bbappends* conf/ -name "*.bb" -o -name "*.bbappend" -o -name "*.inc" | xargs grep -n "PV.*=" 2>/dev/null | grep -i "$pkg" || true
              find recipes* bbappends* conf/ -name "*.bb" -o -name "*.bbappend" -o -name "*.inc" | xargs grep -n "SRCREV.*=" 2>/dev/null | grep -i "$pkg" || true
            fi
          done
          
          # Check for insecure configurations
          echo "Checking for insecure configurations..."
          
          # Check for disabled security features
          security_flags=(
            "INSANE_SKIP.*already-stripped"
            "INSANE_SKIP.*buildpaths"
            "INSANE_SKIP.*textrel"
            "INSANE_SKIP.*ldflags"
            "INSANE_SKIP.*compile-host-path"
            "SECURITY_CFLAGS.*="
            "SECURITY_LDFLAGS.*="
            "FORTIFY_SOURCE.*0"
            "_FORTIFY_SOURCE.*0"
          )
          
          for flag in "${security_flags[@]}"; do
            if find recipes* bbappends* conf/ -name "*.bb" -o -name "*.bbappend" -o -name "*.conf" | xargs grep -n "$flag" 2>/dev/null; then
              echo "âš ï¸  Found potentially insecure configuration: $flag"
            fi
          done
          
          # Check for hardcoded secrets or credentials
          echo "Scanning for hardcoded secrets..."
          
          secret_patterns=(
            "password.*="
            "passwd.*="
            "secret.*="
            "key.*="
            "token.*="
            "api_key"
            "private_key"
            "ssh_key"
            "rsa_key"
            "certificate"
          )
          
          for pattern in "${secret_patterns[@]}"; do
            if find recipes* bbappends* conf/ -name "*.bb" -o -name "*.bbappend" -o -name "*.conf" | xargs grep -in "$pattern" 2>/dev/null | grep -v "DESCRIPTION\|SUMMARY\|HOMEPAGE" | head -5; then
              echo "âš ï¸  Potential hardcoded secret found matching: $pattern"
            fi
          done
          
          # Check for insecure network configurations
          echo "Checking for insecure network configurations..."
          
          insecure_network=(
            "http://.*download"
            "ftp://.*download"
            "DISABLE_STATIC.*0"
            "ALLOW_EMPTY.*1"
            "INSANE_SKIP.*host-user-contaminated"
          )
          
          for pattern in "${insecure_network[@]}"; do
            if find recipes* bbappends* conf/ -name "*.bb" -o -name "*.bbappend" -o -name "*.conf" | xargs grep -n "$pattern" 2>/dev/null; then
              echo "âš ï¸  Insecure network configuration found: $pattern"
            fi
          done
          
          # Check for proper license compliance (security through legal compliance)
          echo "Checking license compliance..."
          
          if find recipes* bbappends* -name "*.bb" -o -name "*.bbappend" | xargs grep -L "LICENSE.*=" 2>/dev/null | head -5; then
            echo "âš ï¸  Recipes missing LICENSE declaration found"
          fi
          
          # Check for CLOSED license (potential proprietary/security issues)
          if find recipes* bbappends* -name "*.bb" -o -name "*.bbappend" | xargs grep -n "LICENSE.*CLOSED" 2>/dev/null; then
            echo "âš ï¸  Found recipes with CLOSED license - review for security implications"
          fi
          
          echo "âœ… CVE and security scanning complete"

      - name: Check for security-related TODOs and FIXMEs
        run: |
          echo "ðŸ” Scanning for security-related TODOs and issues..."
          
          security_keywords=(
            "TODO.*security"
            "FIXME.*security"
            "TODO.*cve"
            "FIXME.*cve"
            "TODO.*vuln"
            "FIXME.*vuln"
            "TODO.*exploit"
            "FIXME.*exploit"
            "HACK.*security"
            "XXX.*security"
          )
          
          found_issues=0
          for keyword in "${security_keywords[@]}"; do
            if find . -name "*.bb" -o -name "*.bbappend" -o -name "*.conf" -o -name "*.sh" -o -name "*.py" | xargs grep -in "$keyword" 2>/dev/null; then
              echo "âš ï¸  Security-related TODO/FIXME found: $keyword"
              found_issues=$((found_issues + 1))
            fi
          done
          
          if [ $found_issues -gt 0 ]; then
            echo "âš ï¸  Found $found_issues security-related TODOs/FIXMEs that should be addressed"
          else
            echo "âœ… No security-related TODOs/FIXMEs found"
          fi

      - name: Validate build reproducibility settings
        run: |
          echo "ðŸ”„ Checking build reproducibility and security settings..."
          
          # Check for SOURCE_DATE_EPOCH usage
          if ! find conf/ -name "*.conf" | xargs grep -q "SOURCE_DATE_EPOCH" 2>/dev/null; then
            echo "âš ï¸  SOURCE_DATE_EPOCH not configured - builds may not be reproducible"
          fi
          
          # Check for proper DISTRO security features
          security_features=(
            "DISTRO_FEATURES.*pam"
            "DISTRO_FEATURES.*systemd"
            "DISTRO_FEATURES.*selinux"
            "DISTRO_FEATURES.*smack"
            "DISTRO_FEATURES.*ima"
          )
          
          echo "Checking security-related DISTRO_FEATURES..."
          for feature in "${security_features[@]}"; do
            if find conf/ -name "*.conf" | xargs grep -q "$feature" 2>/dev/null; then
              echo "âœ… Found security feature: $feature"
            fi
          done
          
          # Check for security-related IMAGE_FEATURES
          if find conf/ recipes* -name "*.bb" -o -name "*.conf" | xargs grep -q "IMAGE_FEATURES.*ssh-server-openssh" 2>/dev/null; then
            echo "âš ï¸  OpenSSH server enabled - ensure proper key management"
          fi
          
          if find conf/ recipes* -name "*.bb" -o -name "*.conf" | xargs grep -q "IMAGE_FEATURES.*debug-tweaks" 2>/dev/null; then
            echo "âš ï¸  debug-tweaks enabled - should be disabled for production"
          fi
          
          echo "âœ… Build reproducibility and security settings check complete"

      - name: Generate SBOM for recipes
        run: |
          echo "ðŸ“‹ Generating Software Bill of Materials (SBOM) for validation..."
          
          # Create SBOM directory
          mkdir -p sbom-validation
          
          # Generate recipe inventory
          echo "Collecting recipe inventory..."
          cat > sbom-validation/recipe-inventory.json << 'EOF'
          {
            "sbom_version": "1.0",
            "generated_date": "$(date -Iseconds)",
            "generator": "Dynamic Devices CI Pipeline",
            "project": "meta-dynamicdevices",
            "commit": "${{ github.sha }}",
            "recipes": [
          EOF
          
          # Parse all recipes and create inventory
          first_recipe=true
          find recipes* bbappends* -name "*.bb" -o -name "*.bbappend" | while read -r recipe; do
            # Extract basic recipe information
            recipe_name=$(basename "$recipe" | sed 's/_.*\.bb.*//')
            recipe_path="$recipe"
            
            # Extract version if available
            version=$(grep "^PV.*=" "$recipe" 2>/dev/null | cut -d'"' -f2 || echo "unknown")
            if [ "$version" = "unknown" ]; then
              version=$(grep "^PV.*=" "$recipe" 2>/dev/null | cut -d"'" -f2 || echo "unknown")
            fi
            
            # Extract license
            license=$(grep "^LICENSE.*=" "$recipe" 2>/dev/null | cut -d'"' -f2 || echo "unknown")
            if [ "$license" = "unknown" ]; then
              license=$(grep "^LICENSE.*=" "$recipe" 2>/dev/null | cut -d"'" -f2 || echo "unknown")
            fi
            
            # Extract source URI
            src_uri=$(grep "^SRC_URI.*=" "$recipe" 2>/dev/null | head -1 || echo "")
            
            # Extract dependencies
            depends=$(grep "^DEPENDS.*=" "$recipe" 2>/dev/null | cut -d'"' -f2 || echo "")
            rdepends=$(grep "^RDEPENDS.*=" "$recipe" 2>/dev/null | cut -d'"' -f2 || echo "")
            
            # Add comma if not first recipe
            if [ "$first_recipe" = false ]; then
              echo "," >> sbom-validation/recipe-inventory.json
            fi
            first_recipe=false
            
            # Add recipe entry
            cat >> sbom-validation/recipe-inventory.json << EOF
              {
                "name": "$recipe_name",
                "version": "$version",
                "license": "$license",
                "path": "$recipe_path",
                "src_uri": "$src_uri",
                "build_depends": "$depends",
                "runtime_depends": "$rdepends",
                "recipe_type": "$(if [[ $recipe == *.bbappend ]]; then echo 'bbappend'; else echo 'bb'; fi)"
              }
          EOF
          done
          
          # Close JSON
          cat >> sbom-validation/recipe-inventory.json << 'EOF'
            ]
          }
          EOF
          
          echo "âœ… Recipe SBOM inventory generated"
          echo "ðŸ“Š Recipe count: $(find recipes* bbappends* -name "*.bb" -o -name "*.bbappend" | wc -l)"

  # Main build job with matrix strategy
  build:
    runs-on: self-hosted
    needs: [setup, validate]
    if: needs.setup.outputs.should_build == 'true'
    strategy:
      fail-fast: false
      matrix:
        machine: ${{ fromJSON(needs.setup.outputs.machines) }}
        build_type: [base, mfgtool]
        # Build mfgtool for all machines - needed for board programming
    
    env:
      KAS_MACHINE: ${{ matrix.machine }}
      BUILD_TYPE: ${{ matrix.build_type }}
    
    steps:
      - name: Clean up workspace for self-hosted runner
        run: |
          echo "ðŸ§¹ Cleaning up workspace for self-hosted runner"
          # Clean up any previous build artifacts to free space
          if [ -d "${{ github.workspace }}" ]; then
            cd "${{ github.workspace }}"
            # Remove any large build directories from previous runs
            rm -rf build tmp-glibc deploy artifacts programming-packages || true
            # Clean docker containers and images if any
            docker system prune -f || true
          fi

      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Setup Docker environment for Yocto builds
        run: |
          echo "ðŸ³ Setting up Docker environment for Yocto builds"
          
          # Verify Docker is available on self-hosted runner
          if ! command -v docker >/dev/null 2>&1; then
            echo "âŒ Docker not available on self-hosted runner"
            exit 1
          fi
          
          echo "âœ… Docker is available"
          docker --version
          
          # Download kas-container script (minimal host dependency)
          if ! command -v kas-container >/dev/null 2>&1; then
            echo "ðŸ“¥ Downloading kas-container script..."
            wget -O kas-container https://raw.githubusercontent.com/siemens/kas/master/kas-container
            chmod +x kas-container
            # Add to PATH for this workflow
            echo "$PWD" >> $GITHUB_PATH
          else
            echo "âœ… kas-container already available"
          fi
          
          # Test kas-container works with Docker
          echo "ðŸ§ª Testing kas-container with Docker..."
          ./kas-container --help > /dev/null
          echo "âœ… kas-container is ready"

      - name: Setup persistent cache for Docker builds
        run: |
          echo "ðŸ—„ï¸ Setting up persistent build cache for Docker-based Yocto builds"
          
          # Use a persistent cache directory on the self-hosted runner
          # This will be mounted into the Docker container by kas-container
          CACHE_BASE="$HOME/yocto-cache"
          BUILD_DIR="$HOME/yocto-builds"
          
          # Create persistent cache and build directories
          mkdir -p "$CACHE_BASE"/{downloads,sstate}
          mkdir -p "$BUILD_DIR"
          
          echo "ðŸ“Š Cache directory sizes:"
          du -sh "$CACHE_BASE"/* 2>/dev/null || echo "Cache directories are empty (first run)"
          
          echo "ðŸ—ï¸ Build directory:"
          ls -la "$BUILD_DIR" 2>/dev/null || echo "Build directory is empty (first run)"
          
          # Export paths for kas-container to use
          echo "KAS_WORK_DIR=$BUILD_DIR" >> $GITHUB_ENV
          echo "DL_DIR=$CACHE_BASE/downloads" >> $GITHUB_ENV
          echo "SSTATE_DIR=$CACHE_BASE/sstate" >> $GITHUB_ENV
          
          echo "âœ… Docker build environment configured:"
          echo "   Work dir: $BUILD_DIR"
          echo "   Downloads: $CACHE_BASE/downloads"
          echo "   SSstate: $CACHE_BASE/sstate"

      - name: Set up build environment for self-hosted runner
        run: |
          echo "ðŸš€ Setting up build environment for ${{ matrix.machine }} (${{ matrix.build_type }})"
          
          # Create yocto cache directories (persistent symlinks already created)
          mkdir -p ~/yocto/persistent
          chmod 755 ~/yocto/persistent
          
          # Detect available CPU cores for optimal parallel builds
          NPROC=$(nproc)
          # Use 75% of available cores to leave some for system
          BUILD_THREADS=$((NPROC * 3 / 4))
          BUILD_THREADS=${BUILD_THREADS:-4}  # Minimum 4 threads
          
          echo "ðŸ–¥ï¸ Self-hosted runner specs:"
          echo "  CPU cores: $NPROC"
          echo "  Build threads: $BUILD_THREADS"
          echo "  RAM: $(free -h | awk '/^Mem:/ {print $2}')"
          echo "  Disk space: $(df -h . | awk 'NR==2 {print $4}')"
          
          # Set optimized environment variables for self-hosted runner
          echo "BB_NUMBER_THREADS=$BUILD_THREADS" >> $GITHUB_ENV
          echo "PARALLEL_MAKE=-j$BUILD_THREADS" >> $GITHUB_ENV
          
          # Disable interactive features
          echo "DEBIAN_FRONTEND=noninteractive" >> $GITHUB_ENV
          
          # For development builds, disable signing to avoid key issues
          echo "OPTEE_TA_SIGN_ENABLE=0" >> $GITHUB_ENV
          echo "SIGN_ENABLE=0" >> $GITHUB_ENV
          echo "UBOOT_SIGN_ENABLE=0" >> $GITHUB_ENV
          echo "UBOOT_SPL_SIGN_ENABLE=0" >> $GITHUB_ENV
          echo "TF_A_SIGN_ENABLE=0" >> $GITHUB_ENV
          echo "UEFI_SIGN_ENABLE=0" >> $GITHUB_ENV

      - name: Build with KAS
        timeout-minutes: 240  # 4 hour timeout
        run: |
          echo "ðŸ”¨ Starting KAS build: ${{ matrix.machine }} (${{ matrix.build_type }})"
          
          # Select appropriate KAS configuration
          if [ "${{ matrix.build_type }}" = "mfgtool" ]; then
            kas_config="kas/lmp-dynamicdevices-mfgtool.yml"
          else
            kas_config="kas/lmp-dynamicdevices-base.yml"
          fi
          
          echo "Using KAS config: $kas_config"
          echo "Machine: $KAS_MACHINE"
          
          # Run KAS build in Docker container (all tools and dependencies included)
          kas-container \
            --runtime-args "-v $DL_DIR:/downloads \
                           -v $SSTATE_DIR:/sstate \
                           -e KAS_MACHINE=$KAS_MACHINE \
                           -e DL_DIR=/downloads \
                           -e SSTATE_DIR=/sstate \
                           -e BB_NUMBER_THREADS=$BB_NUMBER_THREADS \
                           -e PARALLEL_MAKE='$PARALLEL_MAKE' \
                           -e OPTEE_TA_SIGN_ENABLE=$OPTEE_TA_SIGN_ENABLE \
                           -e SIGN_ENABLE=$SIGN_ENABLE \
                           -e UBOOT_SIGN_ENABLE=$UBOOT_SIGN_ENABLE \
                           -e UBOOT_SPL_SIGN_ENABLE=$UBOOT_SPL_SIGN_ENABLE \
                           -e TF_A_SIGN_ENABLE=$TF_A_SIGN_ENABLE \
                           -e UEFI_SIGN_ENABLE=$UEFI_SIGN_ENABLE" \
            build "$kas_config"

      - name: Generate build SBOM
        if: always()
        run: |
          echo "ðŸ“‹ Generating Software Bill of Materials for build artifacts..."
          
          # Create SBOM directory
          mkdir -p build-sbom/${{ matrix.machine }}/${{ matrix.build_type }}
          
          # Generate build-specific SBOM
          cat > build-sbom/${{ matrix.machine }}/${{ matrix.build_type }}/sbom.json << EOF
          {
            "sbom_version": "2.3",
            "spdx_version": "SPDX-2.3",
            "document_name": "meta-dynamicdevices-${{ matrix.machine }}-${{ matrix.build_type }}",
            "document_namespace": "https://github.com/DynamicDevices/meta-dynamicdevices",
            "creation_info": {
              "created": "$(date -Iseconds)",
              "creators": ["Tool: Dynamic Devices CI Pipeline"],
              "license_list_version": "3.21"
            },
            "package_info": {
              "name": "meta-dynamicdevices",
              "version": "$(git describe --tags --always)",
              "supplier": "Dynamic Devices Ltd",
              "download_location": "https://github.com/DynamicDevices/meta-dynamicdevices",
              "copyright_text": "NOASSERTION",
              "license_concluded": "GPL-3.0-or-later",
              "license_declared": "GPL-3.0-or-later"
            },
            "build_info": {
              "machine": "${{ matrix.machine }}",
              "build_type": "${{ matrix.build_type }}",
              "kas_config": "$kas_config",
              "commit": "${{ github.sha }}",
              "build_date": "$(date -Iseconds)",
              "build_host": "$(hostname)",
              "yocto_version": "scarthgap"
            }
          }
          EOF
          
          # Add package manifest if available
          deploy_dir="$KAS_WORK_DIR/build/tmp/deploy/images/${{ matrix.machine }}"
          if [ -f "$deploy_dir/lmp-factory-image-${{ matrix.machine }}.manifest" ]; then
            echo "ðŸ“¦ Found image manifest, adding to SBOM..."
            echo '  ,"image_packages": [' >> build-sbom/${{ matrix.machine }}/${{ matrix.build_type }}/sbom.json
            
            # Parse package manifest and add to SBOM
            first_pkg=true
            while IFS= read -r line; do
              if [[ $line =~ ^([^[:space:]]+)[[:space:]]+([^[:space:]]+)[[:space:]]+(.*)$ ]]; then
                pkg_name="${BASH_REMATCH[1]}"
                pkg_version="${BASH_REMATCH[2]}"
                pkg_arch="${BASH_REMATCH[3]}"
                
                if [ "$first_pkg" = false ]; then
                  echo "," >> build-sbom/${{ matrix.machine }}/${{ matrix.build_type }}/sbom.json
                fi
                first_pkg=false
                
                cat >> build-sbom/${{ matrix.machine }}/${{ matrix.build_type }}/sbom.json << EOF
            {
              "name": "$pkg_name",
              "version": "$pkg_version",
              "architecture": "$pkg_arch",
              "supplier": "NOASSERTION",
              "license": "NOASSERTION"
            }
          EOF
              fi
            done < "$deploy_dir/lmp-factory-image-${{ matrix.machine }}.manifest"
            
            echo ']' >> build-sbom/${{ matrix.machine }}/${{ matrix.build_type }}/sbom.json
          fi
          
          # Close JSON
          echo '}' >> build-sbom/${{ matrix.machine }}/${{ matrix.build_type }}/sbom.json
          
          echo "âœ… Build SBOM generated for ${{ matrix.machine }} (${{ matrix.build_type }})"

      - name: Collect build artifacts
        if: always()
        run: |
          echo "ðŸ“¦ Collecting build artifacts for ${{ matrix.machine }} (${{ matrix.build_type }})"
          
          # Create artifacts directories
          mkdir -p artifacts/${{ matrix.machine }}/${{ matrix.build_type }}
          mkdir -p programming-packages/${{ matrix.machine }}
          
          # Define deploy directory (inside the kas work directory)
          deploy_dir="$KAS_WORK_DIR/build/tmp/deploy/images/${{ matrix.machine }}"
          
          if [ -d "$deploy_dir" ]; then
            echo "âœ… Deploy directory found: $deploy_dir"
            
            # Copy all build artifacts
            artifacts=(
              "*.wic.gz"
              "*.wic.bmap"
              "imx-boot-*"
              "u-boot-*.itb"
              "*.dtb"
              "*.manifest"
            )
            
            for pattern in "${artifacts[@]}"; do
              if ls "$deploy_dir"/$pattern 1> /dev/null 2>&1; then
                cp "$deploy_dir"/$pattern artifacts/${{ matrix.machine }}/${{ matrix.build_type }}/
                echo "ðŸ“ Copied to artifacts: $pattern"
              fi
            done
            
            # Create board-specific programming package
            if [ "${{ matrix.build_type }}" = "base" ]; then
              echo "ðŸ“¦ Creating programming package for ${{ matrix.machine }}"
              
              # Files needed for UUU programming (from program_full_image.uuu.in)
              programming_files=(
                "lmp-factory-image-${{ matrix.machine }}.wic.gz"
                "imx-boot-${{ matrix.machine }}"
                "u-boot-${{ matrix.machine }}.itb"
              )
              
              # Copy programming files
              for file in "${programming_files[@]}"; do
                if [ -f "$deploy_dir/$file" ]; then
                  cp "$deploy_dir/$file" programming-packages/${{ matrix.machine }}/
                  echo "ðŸ“‹ Added to programming package: $file"
                else
                  echo "âš ï¸  Programming file not found: $file"
                fi
              done
              
              # Note: mfgtool files will be added by the mfgtool build job
              echo "ðŸ“‹ Base build complete - mfgtool files will be added by mfgtool build"
            elif [ "${{ matrix.build_type }}" = "mfgtool" ]; then
              echo "ðŸ“¦ Adding mfgtool files to programming package for ${{ matrix.machine }}"
              
              # Mfgtool files needed for UUU programming  
              mfgtool_files=(
                "imx-boot-mfgtool"
                "u-boot-mfgtool.itb"
              )
              
              # Add mfgtool files to existing programming package
              for file in "${mfgtool_files[@]}"; do
                if [ -f "$deploy_dir/$file" ]; then
                  cp "$deploy_dir/$file" programming-packages/${{ matrix.machine }}/
                  echo "ðŸ“‹ Added mfgtool file: $file"
                else
                  echo "âš ï¸  Mfgtool file not found: $file"
                fi
              done
              
              # Update the programming script to indicate mfgtool files are now available
              if [ -f "programming-packages/${{ matrix.machine }}/program-${{ matrix.machine }}.sh" ]; then
                echo "ðŸ“‹ Mfgtool files added to existing programming package"
              else
                echo "âš ï¸  Programming package not found - base build may have failed"
              fi
              
              # Create programming script for this machine
              cat > programming-packages/${{ matrix.machine }}/program-${{ matrix.machine }}.sh << 'EOF'
          #!/bin/bash
          # Board Programming Script for ${{ matrix.machine }}
          # Generated automatically by CI build
          
          set -e
          
          MACHINE="${{ matrix.machine }}"
          SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
          
          echo "ðŸš€ Programming $MACHINE board..."
          echo "ðŸ“ Using files from: $SCRIPT_DIR"
          
          # Verify required files exist
          required_files=(
              "imx-boot-mfgtool"
              "u-boot-mfgtool.itb"
              "lmp-factory-image-$MACHINE.wic.gz"
              "imx-boot-$MACHINE"
              "u-boot-$MACHINE.itb"
          )
          
          for file in "${required_files[@]}"; do
              if [ ! -f "$SCRIPT_DIR/$file" ]; then
                  echo "âŒ Required file missing: $file"
                  exit 1
              fi
          done
          
          # Create UUU script
          cat > "$SCRIPT_DIR/program_$MACHINE.uuu" << UUU_EOF
          uuu_version 1.2.39
          
          SDP: boot -f imx-boot-mfgtool
          
          SDPV: delay 1000
          SDPV: write -f u-boot-mfgtool.itb
          SDPV: jump
          
          FB: ucmd setenv fastboot_dev mmc
          FB: ucmd setenv mmcdev \${emmc_dev}
          FB: ucmd mmc dev \${emmc_dev} 1; mmc erase 0 0x2000
          FB: flash -raw2sparse all lmp-factory-image-$MACHINE.wic.gz/*
          FB: flash bootloader imx-boot-$MACHINE
          FB: flash bootloader2 u-boot-$MACHINE.itb
          FB: flash bootloader_s imx-boot-$MACHINE
          FB: flash bootloader2_s u-boot-$MACHINE.itb
          FB: ucmd if env exists emmc_ack; then ; else setenv emmc_ack 0; fi;
          FB: ucmd mmc partconf \${emmc_dev} \${emmc_ack} 1 0
          FB: done
          UUU_EOF
          
          echo "âœ… Created UUU script: program_$MACHINE.uuu"
          echo "ðŸ”Œ Connect board in download mode and run:"
          echo "   sudo uuu program_$MACHINE.uuu"
          
          # Optionally run UUU if requested
          if [ "${1:-}" = "--flash" ]; then
              echo "ðŸš€ Starting board programming..."
              sudo uuu "program_$MACHINE.uuu"
          fi
          EOF
              
              chmod +x programming-packages/${{ matrix.machine }}/program-${{ matrix.machine }}.sh
              
              # Create README for programming package
              cat > programming-packages/${{ matrix.machine }}/README.md << 'EOF'
          # Programming Package for ${{ matrix.machine }}
          
          **Generated**: $(date)  
          **Commit**: ${{ github.sha }}  
          **Branch**: ${{ github.ref_name }}
          
          ## Files Included
          
          ### Bootloaders
          - `imx-boot-mfgtool` - Manufacturing tool bootloader
          - `u-boot-mfgtool.itb` - Manufacturing tool U-Boot
          - `imx-boot-${{ matrix.machine }}` - Production bootloader  
          - `u-boot-${{ matrix.machine }}.itb` - Production U-Boot
          
          ### System Image
          - `lmp-factory-image-${{ matrix.machine }}.wic.gz` - Complete system image
          
          ### Programming Tools
          - `program-${{ matrix.machine }}.sh` - Automated programming script
          - `program_${{ matrix.machine }}.uuu` - UUU programming script (auto-generated)
          
          ## Usage
          
          ### Prerequisites
          - Install NXP UUU tool
          - Connect ${{ matrix.machine }} board via USB in download mode
          
          ### Programming Steps
          
          1. **Put board in download mode**
          2. **Connect USB cable**
          3. **Run programming script**:
             ```bash
             ./program-${{ matrix.machine }}.sh --flash
             ```
          
          ### Manual Programming
          
          If you prefer manual control:
          ```bash
          sudo uuu program_${{ matrix.machine }}.uuu
          ```
          
          ## Board-Specific Notes
          
          - **Machine**: ${{ matrix.machine }}
          - **Architecture**: $(echo "${{ matrix.machine }}" | grep -q "imx8mm" && echo "i.MX8M Mini" || echo "i.MX93")
          - **Board Type**: $(echo "${{ matrix.machine }}" | sed 's/.*jaguar-//' | tr '[:lower:]' '[:upper:]')
          
          EOF
            fi
            
            # Create build artifact summary
            echo "# Build Artifacts for ${{ matrix.machine }} (${{ matrix.build_type }})" > artifacts/${{ matrix.machine }}/${{ matrix.build_type }}/README.md
            echo "Generated on: $(date)" >> artifacts/${{ matrix.machine }}/${{ matrix.build_type }}/README.md
            echo "Commit: ${{ github.sha }}" >> artifacts/${{ matrix.machine }}/${{ matrix.build_type }}/README.md
            echo "" >> artifacts/${{ matrix.machine }}/${{ matrix.build_type }}/README.md
            echo "## Files:" >> artifacts/${{ matrix.machine }}/${{ matrix.build_type }}/README.md
            
            cd artifacts/${{ matrix.machine }}/${{ matrix.build_type }}
            for file in *; do
              if [ "$file" != "README.md" ]; then
                size=$(du -h "$file" | cut -f1)
                echo "- $file ($size)" >> README.md
              fi
            done
            cd ../../../
            
          else
            echo "âŒ Deploy directory not found: $deploy_dir"
            echo "Available directories in kas work dir:"
            ls -la "$KAS_WORK_DIR/build/tmp/deploy/" 2>/dev/null || echo "No deploy directory found"
            echo "Available directories in kas work dir build:"
            ls -la "$KAS_WORK_DIR/build/" 2>/dev/null || echo "No build directory found"
          fi

      - name: Upload build artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: build-artifacts-${{ matrix.machine }}-${{ matrix.build_type }}
          path: artifacts/
          retention-days: 30
          if-no-files-found: warn

      - name: Upload SBOM artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: sbom-${{ matrix.machine }}-${{ matrix.build_type }}
          path: build-sbom/
          retention-days: 90
          if-no-files-found: warn

      - name: Upload programming packages
        if: always() && matrix.build_type == 'base'
        uses: actions/upload-artifact@v4
        with:
          name: programming-package-${{ matrix.machine }}
          path: programming-packages/${{ matrix.machine }}/
          retention-days: 90
          if-no-files-found: warn

      - name: Generate build report
        if: always()
        run: |
          echo "ðŸ“Š Generating build report"
          
          # Create build report
          cat > build-report-${{ matrix.machine }}-${{ matrix.build_type }}.md << EOF
          # Build Report: ${{ matrix.machine }} (${{ matrix.build_type }})
          
          **Date:** $(date)
          **Commit:** ${{ github.sha }}
          **Branch:** ${{ github.ref_name }}
          **Workflow:** ${{ github.workflow }}
          **Run:** ${{ github.run_number }}
          
          ## Build Configuration
          - **Machine:** ${{ matrix.machine }}
          - **Build Type:** ${{ matrix.build_type }}
          - **KAS Configuration:** $([ "${{ matrix.build_type }}" = "mfgtool" ] && echo "kas/lmp-dynamicdevices-mfgtool.yml" || echo "kas/lmp-dynamicdevices-base.yml")
          
          ## Build Status
          - **Status:** ${{ job.status }}
          - **Duration:** \$(expr \$SECONDS / 60) minutes
          
          ## Build Environment
          - **Runner:** ubuntu-latest
          - **Parallel Jobs:** \$BB_NUMBER_THREADS
          - **Make Jobs:** \$PARALLEL_MAKE
          
          ## Security Configuration
          - **Signing Disabled:** Development build (CI environment)
          
          EOF
          
          # Check if artifacts were created
          if [ -d "artifacts/${{ matrix.machine }}/${{ matrix.build_type }}" ]; then
            echo "## Artifacts Generated" >> build-report-${{ matrix.machine }}-${{ matrix.build_type }}.md
            echo "âœ… Build artifacts available for download" >> build-report-${{ matrix.machine }}-${{ matrix.build_type }}.md
          else
            echo "## Artifacts" >> build-report-${{ matrix.machine }}-${{ matrix.build_type }}.md
            echo "âŒ No artifacts generated" >> build-report-${{ matrix.machine }}-${{ matrix.build_type }}.md
          fi

      - name: Upload build report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: build-report-${{ matrix.machine }}-${{ matrix.build_type }}
          path: build-report-${{ matrix.machine }}-${{ matrix.build_type }}.md
          retention-days: 90

  # Create final programming packages combining base + mfgtool artifacts
  create-programming-packages:
    runs-on: self-hosted
    needs: [setup, build]
    # Only create programming packages if the build job succeeded
    if: needs.setup.outputs.should_build == 'true' && needs.build.result == 'success'
    strategy:
      matrix:
        machine: ${{ fromJSON(needs.setup.outputs.machines) }}
    steps:
      - name: Download base build artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-artifacts-${{ matrix.machine }}-base
          path: base-artifacts/
        continue-on-error: false  # Fail if base artifacts missing

      - name: Download mfgtool build artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-artifacts-${{ matrix.machine }}-mfgtool
          path: mfgtool-artifacts/
        continue-on-error: false  # Fail if mfgtool artifacts missing

      - name: Create complete programming package
        run: |
          echo "ðŸ“¦ Creating complete programming package for ${{ matrix.machine }}"
          
          # Verify both base and mfgtool artifacts are available
          if [ ! -d "base-artifacts/${{ matrix.machine }}/base" ]; then
            echo "âŒ Base build artifacts missing for ${{ matrix.machine }}"
            exit 1
          fi
          
          if [ ! -d "mfgtool-artifacts/${{ matrix.machine }}/mfgtool" ]; then
            echo "âŒ Mfgtool build artifacts missing for ${{ matrix.machine }}"
            exit 1
          fi
          
          echo "âœ… Both base and mfgtool artifacts found for ${{ matrix.machine }}"
          
          # Create programming package directory
          mkdir -p programming-packages/${{ matrix.machine }}
          
          # Copy base build files (already verified to exist)
          echo "ðŸ“‹ Adding base build files..."
          
          # Files needed for UUU programming
          base_files=(
            "lmp-factory-image-${{ matrix.machine }}.wic.gz"
            "imx-boot-${{ matrix.machine }}"
            "u-boot-${{ matrix.machine }}.itb"
          )
          
          missing_base_files=()
          for file in "${base_files[@]}"; do
            if [ -f "base-artifacts/${{ matrix.machine }}/base/$file" ]; then
              cp "base-artifacts/${{ matrix.machine }}/base/$file" "programming-packages/${{ matrix.machine }}/"
              echo "âœ… Added: $file"
            else
              missing_base_files+=("$file")
            fi
          done
          
          if [ ${#missing_base_files[@]} -gt 0 ]; then
            echo "âŒ Missing base files:"
            printf '  - %s\n' "${missing_base_files[@]}"
            exit 1
          fi
          
          # Copy mfgtool files (already verified to exist)
          echo "ðŸ“‹ Adding mfgtool files..."
          
          # Mfgtool files
          mfgtool_files=(
            "imx-boot-mfgtool"
            "u-boot-mfgtool.itb"
          )
          
          missing_mfgtool_files=()
          for file in "${mfgtool_files[@]}"; do
            if [ -f "mfgtool-artifacts/${{ matrix.machine }}/mfgtool/$file" ]; then
              cp "mfgtool-artifacts/${{ matrix.machine }}/mfgtool/$file" "programming-packages/${{ matrix.machine }}/"
              echo "âœ… Added: $file"
            else
              missing_mfgtool_files+=("$file")
            fi
          done
          
          if [ ${#missing_mfgtool_files[@]} -gt 0 ]; then
            echo "âŒ Missing mfgtool files:"
            printf '  - %s\n' "${missing_mfgtool_files[@]}"
            exit 1
          fi
          
          # Copy SBOM files to programming package
          echo "ðŸ“‹ Adding SBOM files to programming package..."
          if [ -d "base-artifacts/${{ matrix.machine }}/base" ]; then
            # Copy base build SBOM if available
            if ls build-sbom/${{ matrix.machine }}/base/*.json 1> /dev/null 2>&1; then
              cp build-sbom/${{ matrix.machine }}/base/*.json "programming-packages/${{ matrix.machine }}/" 2>/dev/null || true
              echo "âœ… Added base SBOM to programming package"
            fi
          fi
          
          if [ -d "mfgtool-artifacts/${{ matrix.machine }}/mfgtool" ]; then
            # Copy mfgtool SBOM if available
            if ls build-sbom/${{ matrix.machine }}/mfgtool/*.json 1> /dev/null 2>&1; then
              cp build-sbom/${{ matrix.machine }}/mfgtool/*.json "programming-packages/${{ matrix.machine }}/" 2>/dev/null || true
              echo "âœ… Added mfgtool SBOM to programming package"
            fi
          fi
          
          # Create programming script
          cat > programming-packages/${{ matrix.machine }}/program-${{ matrix.machine }}.sh << 'EOF'
          #!/bin/bash
          # Board Programming Script for ${{ matrix.machine }}
          # Generated automatically by CI build
          
          set -e
          
          MACHINE="${{ matrix.machine }}"
          SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
          
          echo "ðŸš€ Programming $MACHINE board..."
          echo "ðŸ“ Using files from: $SCRIPT_DIR"
          
          # Verify required files exist
          required_files=(
              "imx-boot-mfgtool"
              "u-boot-mfgtool.itb"
              "lmp-factory-image-$MACHINE.wic.gz"
              "imx-boot-$MACHINE"
              "u-boot-$MACHINE.itb"
          )
          
          missing_files=()
          for file in "${required_files[@]}"; do
              if [ ! -f "$SCRIPT_DIR/$file" ]; then
                  missing_files+=("$file")
              fi
          done
          
          if [ ${#missing_files[@]} -gt 0 ]; then
              echo "âŒ Missing required files:"
              printf '  - %s\n' "${missing_files[@]}"
              echo ""
              echo "Available files:"
              ls -la "$SCRIPT_DIR"
              exit 1
          fi
          
          echo "âœ… All required files present"
          
          # Create UUU script
          cat > "$SCRIPT_DIR/program_$MACHINE.uuu" << UUU_EOF
          uuu_version 1.2.39
          
          SDP: boot -f imx-boot-mfgtool
          
          SDPV: delay 1000
          SDPV: write -f u-boot-mfgtool.itb
          SDPV: jump
          
          FB: ucmd setenv fastboot_dev mmc
          FB: ucmd setenv mmcdev \${emmc_dev}
          FB: ucmd mmc dev \${emmc_dev} 1; mmc erase 0 0x2000
          FB: flash -raw2sparse all lmp-factory-image-$MACHINE.wic.gz/*
          FB: flash bootloader imx-boot-$MACHINE
          FB: flash bootloader2 u-boot-$MACHINE.itb
          FB: flash bootloader_s imx-boot-$MACHINE
          FB: flash bootloader2_s u-boot-$MACHINE.itb
          FB: ucmd if env exists emmc_ack; then ; else setenv emmc_ack 0; fi;
          FB: ucmd mmc partconf \${emmc_dev} \${emmc_ack} 1 0
          FB: done
          UUU_EOF
          
          echo "âœ… Created UUU script: program_$MACHINE.uuu"
          echo ""
          echo "ðŸ”Œ To program the board:"
          echo "  1. Put board in download mode"
          echo "  2. Connect USB cable"
          echo "  3. Run: sudo uuu program_$MACHINE.uuu"
          echo ""
          echo "Or use this script with --flash to program automatically:"
          echo "  ./program-$MACHINE.sh --flash"
          
          # Optionally run UUU if requested
          if [ "${1:-}" = "--flash" ]; then
              echo "ðŸš€ Starting board programming..."
              if command -v uuu >/dev/null 2>&1; then
                  sudo uuu "program_$MACHINE.uuu"
              else
                  echo "âŒ UUU tool not found. Please install NXP UUU tool first."
                  exit 1
              fi
          fi
          EOF
          
          chmod +x programming-packages/${{ matrix.machine }}/program-${{ matrix.machine }}.sh
          
          # Create comprehensive step-by-step README
          cat > programming-packages/${{ matrix.machine }}/README.md << 'EOF'
          # ðŸš€ Board Programming Guide: ${{ matrix.machine }}
          
          > **Complete step-by-step instructions for programming your Dynamic Devices board**
          
          **Generated**: $(date)  
          **Commit**: ${{ github.sha }}  
          **Branch**: ${{ github.ref_name }}  
          **Build**: ${{ github.run_number }}
          
          ## ðŸ“¦ What's In This Package
          
          This programming package contains everything needed to flash your board:
          
          ### ðŸ”§ Manufacturing Tools
          - `imx-boot-mfgtool` - Special bootloader for programming mode
          - `u-boot-mfgtool.itb` - Programming U-Boot environment
          
          ### ðŸ’¾ Production Firmware  
          - `imx-boot-${{ matrix.machine }}` - Your board's production bootloader
          - `u-boot-${{ matrix.machine }}.itb` - Your board's production U-Boot
          - `lmp-factory-image-${{ matrix.machine }}.wic.gz` - Complete Linux system image
          
          ### ðŸ› ï¸ Programming Scripts
          - `program-${{ matrix.machine }}.sh` - **START HERE** - Automated programming script
          - `program_${{ matrix.machine }}.uuu` - Low-level UUU commands (auto-generated)
          
          ### ðŸ“‹ Security & Compliance
          - `sbom.json` - Software Bill of Materials (SPDX format)
          - `*.manifest` - Package manifest files for traceability
          
          ---
          
          ## âš¡ Quick Start (5 Minutes)
          
          ### **Step 1: Install UUU Tool** ðŸ“¥
          
          #### Option A: Package Manager (Recommended)
          ```bash
          # Ubuntu/Debian
          sudo apt update && sudo apt install uuu
          
          # Fedora/CentOS/RHEL
          sudo dnf install uuu
          
          # Arch Linux
          sudo pacman -S uuu
          ```
          
          #### Option B: Direct Download
          ```bash
          # Download latest UUU
          wget https://github.com/nxp-imx/mfgtools/releases/latest/download/uuu
          chmod +x uuu
          sudo mv uuu /usr/local/bin/
          
          # Verify installation
          uuu --help
          ```
          
          ### **Step 2: Prepare Your Board** ðŸ”Œ
          
          #### **Physical Setup:**
          1. **Power OFF** your board completely
          2. **Locate boot switches** on your board (usually near USB connector)
          3. **Set to download mode**:
             - Consult your board manual for exact switch positions
             - Typically involves setting specific DIP switches or jumpers
          4. **Connect USB cable** from board to your computer
          5. **Power ON** your board
          
          #### **Verify Download Mode:**
          ```bash
          # Check if board is detected
          lsusb | grep -i "NXP\|Freescale"
          
          # Should show something like:
          # Bus 001 Device 005: ID 1fc9:012f NXP Semiconductors
          ```
          
          ### **Step 3: Program Your Board** âš¡
          
          #### **Automated Programming (Easiest):**
          ```bash
          # Navigate to this directory
          cd programming-package-${{ matrix.machine }}/
          
          # Make script executable (if needed)
          chmod +x program-${{ matrix.machine }}.sh
          
          # Program the board (takes 3-5 minutes)
          ./program-${{ matrix.machine }}.sh --flash
          ```
          
          #### **Manual Programming (Advanced):**
          ```bash
          # Use UUU directly
          sudo uuu program_${{ matrix.machine }}.uuu
          ```
          
          ### **Step 4: First Boot** ðŸŽ‰
          
          1. **Programming complete** - Wait for "Programming successful" message
          2. **Power OFF** the board
          3. **Set switches back** to normal boot mode (consult board manual)
          4. **Power ON** the board
          5. **Wait 30-60 seconds** for first boot (may take longer initially)
          6. **Connect via serial** or **SSH** to access your board
          
          ---
          
          ## ðŸŽ¯ Board-Specific Information
          
          ### **Board Details:**
          - **Machine**: ${{ matrix.machine }}
          - **Architecture**: $(echo "${{ matrix.machine }}" | grep -q "imx8mm" && echo "i.MX8M Mini (Cortex-A53)" || echo "i.MX93 (Cortex-A55)")
          - **Board Type**: $(echo "${{ matrix.machine }}" | sed 's/.*jaguar-//' | tr '[:lower:]' '[:upper:]')
          - **Flash Memory**: eMMC internal storage
          
          ### **What Gets Programmed:**
          1. **Bootloader** - Low-level boot code
          2. **U-Boot** - Boot environment and configuration  
          3. **Linux Kernel** - Operating system kernel
          4. **Root Filesystem** - Complete Linux system with applications
          
          ---
          
          ## âš ï¸ Troubleshooting
          
          ### **Board Not Detected**
          
          **Problem**: `lsusb` doesn't show NXP device
          
          **Solutions**:
          - âœ… Verify USB cable is data cable (not power-only)
          - âœ… Try different USB port on your computer
          - âœ… Check boot switches are in correct download position
          - âœ… Power cycle the board (off/on)
          - âœ… Check board manual for exact switch positions
          
          ### **Programming Fails**
          
          **Problem**: UUU shows errors or timeouts
          
          **Solutions**:
          - âœ… Run with `sudo` privileges: `sudo ./program-${{ matrix.machine }}.sh --flash`
          - âœ… Verify all files are present: `ls -la *.gz *.itb imx-boot-*`
          - âœ… Check UUU version: `uuu --version` (should be 1.4.0+)
          - âœ… Try manual programming: `sudo uuu program_${{ matrix.machine }}.uuu`
          - âœ… Check USB connection stability
          
          ### **Board Won't Boot After Programming**
          
          **Problem**: Board doesn't start after programming
          
          **Solutions**:
          - âœ… **Check boot switches** - Must be in NORMAL boot mode (not download mode)
          - âœ… **Power cycle** the board completely
          - âœ… **Wait longer** - First boot can take 2-3 minutes
          - âœ… **Check serial console** for boot messages
          - âœ… **Re-program** if needed (board should still be recoverable)
          
          ### **Permissions Errors**
          
          **Problem**: "Permission denied" when accessing USB device
          
          **Solutions**:
          ```bash
          # Add yourself to dialout group
          sudo usermod -a -G dialout $USER
          
          # Or run with sudo
          sudo ./program-${{ matrix.machine }}.sh --flash
          
          # Log out and back in for group changes to take effect
          ```
          
          ---
          
          ## ðŸ”§ Advanced Usage
          
          ### **Verify Programming Before Boot**
          ```bash
          # Check all required files are present
          ls -la imx-boot-* u-boot-* *.wic.gz
          
          # Verify file sizes (should not be 0 bytes)
          du -h *
          ```
          
          ### **Custom UUU Commands**
          ```bash
          # View the UUU script that will be executed
          cat program_${{ matrix.machine }}.uuu
          
          # Run individual UUU commands for debugging
          sudo uuu -v program_${{ matrix.machine }}.uuu
          ```
          
          ### **Recovery Mode**
          If your board becomes unbootable, you can always recover by:
          1. Putting board back in download mode
          2. Re-running the programming process
          3. The board should always be recoverable via this method
          
          ---
          
          ## ðŸ“ž Support
          
          ### **Documentation**
          - **Board Wiki**: https://github.com/DynamicDevices/meta-dynamicdevices/wiki
          - **Troubleshooting**: https://github.com/DynamicDevices/meta-dynamicdevices/wiki/Troubleshooting
          
          ### **Need Help?**
          - **GitHub Issues**: https://github.com/DynamicDevices/meta-dynamicdevices/issues
          - **Email Support**: support@dynamicdevices.co.uk
          
          ### **Professional Services**
          For custom development, integration support, or commercial licensing:
          - **Contact**: licensing@dynamicdevices.co.uk
          - **Website**: https://dynamicdevices.co.uk
          
          ---
          
          **âœ… Programming successful? Your board should now boot to a fully functional Linux system with networking, containers, and development tools ready!**
          
          EOF

      - name: Upload complete programming package
        uses: actions/upload-artifact@v4
        with:
          name: programming-package-${{ matrix.machine }}
          path: programming-packages/${{ matrix.machine }}/
          retention-days: 90
          if-no-files-found: warn

  # Summary job that creates overall build status
  summary:
    runs-on: self-hosted
    needs: [setup, build, create-programming-packages]
    if: always() && needs.setup.outputs.should_build == 'true'
    steps:
      - name: Generate build summary
        run: |
          echo "# KAS Build CI Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Workflow:** ${{ github.workflow }}" >> $GITHUB_STEP_SUMMARY
          echo "**Trigger:** ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "**Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Determine overall status
          if [ "${{ needs.build.result }}" = "success" ]; then
            echo "## âœ… Build Status: SUCCESS" >> $GITHUB_STEP_SUMMARY
            echo "All builds completed successfully!" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ needs.build.result }}" = "failure" ]; then
            echo "## âŒ Build Status: FAILURE" >> $GITHUB_STEP_SUMMARY
            echo "One or more builds failed. Check individual job logs for details." >> $GITHUB_STEP_SUMMARY
          else
            echo "## âš ï¸ Build Status: ${{ needs.build.result }}" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Build Matrix" >> $GITHUB_STEP_SUMMARY
          echo "Machines built: ${{ needs.setup.outputs.machines }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Artifacts" >> $GITHUB_STEP_SUMMARY
          echo "Build artifacts and reports are available in the workflow artifacts section." >> $GITHUB_STEP_SUMMARY

      - name: Update issue status
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        run: |
          echo "Updating GitHub issue #14 with CI status"
          # This would update the issue, but requires GitHub token with appropriate permissions
          # For now, just log the intent
          echo "CI build completed with status: ${{ needs.build.result }}"
