name: KAS Build CI

on:
  push:
    branches: [ main, develop ]
    paths:
      - 'recipes-**'
      - 'conf/**'
      - 'kas/**'
      - 'scripts/**'
      - 'classes/**'
      - '.github/workflows/kas-build-ci.yml'
  pull_request:
    branches: [ main, develop ]
    paths:
      - 'recipes-**'
      - 'conf/**'
      - 'kas/**'
      - 'scripts/**'
      - 'classes/**'
      - '.github/workflows/kas-build-ci.yml'
  workflow_dispatch:
    inputs:
      machine:
        description: 'Specific machine to build (optional)'
        required: false
        type: choice
        options:
          - 'all'
          - 'imx8mm-jaguar-sentai'
          - 'imx93-jaguar-eink'
        default: 'all'

jobs:
  # Layer validation job - runs once before builds
  validate:
    name: Validate Yocto Layer Compliance
    runs-on: self-hosted
    container:
      image: dynamicdevices/yocto-ci-build:latest
      options: --privileged --platform linux/amd64  -v /dev/net/tun:/dev/net/tun -v /dev/kvm:/dev/kvm
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Validate Yocto Layers
        run: |
          echo "ðŸ… Validating Yocto layers using yocto-check-layer"
          echo "ðŸ“‹ Testing layers: meta-dynamicdevices, meta-dynamicdevices-bsp, meta-dynamicdevices-distro"
          
          # Initialize Yocto build environment using kas to get the right layers and setup
          echo "ðŸ”§ Setting up Yocto environment with kas..."
          kas checkout kas/lmp-dynamicdevices-base.yml
          
          # Initialize the BitBake environment properly
          echo "ðŸ”§ Initializing BitBake environment..."
          cd build
          
          # Source the oe-init-build-env to set up BitBake environment
          if [ -f "layers/openembedded-core/oe-init-build-env" ]; then
            source layers/openembedded-core/oe-init-build-env .
            echo "âœ… BitBake environment initialized"
          else
            echo "âŒ oe-init-build-env not found"
            exit 1
          fi
          
          # Go back to the repository root for layer validation
          cd ..
          
          # Find yocto-check-layer script in the checked out layers
          YOCTO_CHECK_LAYER=$(find . -name 'yocto-check-layer' -type f | head -1)
          if [ -z "$YOCTO_CHECK_LAYER" ]; then
            echo 'âŒ yocto-check-layer script not found'
            exit 1
          fi
          
          echo "âœ… Found yocto-check-layer: $YOCTO_CHECK_LAYER"
          
          # Verify BitBake is available
          if ! python3 -c "import bb.tinfoil" 2>/dev/null; then
            echo "âŒ BitBake environment not properly initialized"
            echo "PYTHONPATH: $PYTHONPATH"
            echo "PATH: $PATH"
            exit 1
          fi
          
          echo "âœ… BitBake environment verified"
          
          # Remove BitBake test data to avoid collection conflicts
          echo "ðŸ”§ Removing BitBake test data to avoid collection conflicts..."
          if [ -d "build/layers/bitbake/lib/layerindexlib/tests/testdata" ]; then
            rm -rf build/layers/bitbake/lib/layerindexlib/tests/testdata
            echo "âœ… Removed BitBake test data"
          fi
          
          # Check what layers kas checkout actually fetched
          echo "ðŸ”§ Checking layers fetched by kas checkout..."
          find build/layers -name "layer.conf" -type f | head -10
          
          # Run yocto-check-layer with dependency layers
          echo 'ðŸ”§ Validating layers with required dependencies:'
          echo '   - . (meta-dynamicdevices)'
          echo '   - ./meta-dynamicdevices-bsp'
          echo '   - ./meta-dynamicdevices-distro'
          echo '   - Dependencies: meta-lmp-base, openembedded-core, meta-oe'
          
          # Build the yocto-check-layer command with dependencies
          YOCTO_CMD="python3 $YOCTO_CHECK_LAYER --dependency build/layers/openembedded-core/meta --dependency build/layers/meta-openembedded/meta-oe --dependency build/layers/meta-lmp-base . ./meta-dynamicdevices-bsp ./meta-dynamicdevices-distro"
          
          echo "ðŸ”§ EXACT COMMAND BEING EXECUTED:"
          echo "$YOCTO_CMD"
          echo ""
          
          # Execute the command
          if eval "$YOCTO_CMD"; then
            echo 'âœ… All layer validations PASSED'
          else
            echo 'âŒ Layer validation FAILED'
            exit 1
          fi
          
          echo "âœ… Layer validation completed successfully"

  # Build job with matrix for specific machines and targets
  build:
    name: Build ${{ matrix.machine }} - ${{ matrix.target }}
    runs-on: self-hosted
    container:
      image: dynamicdevices/yocto-ci-build:latest
      options: --privileged --platform linux/amd64  -v /dev/net/tun:/dev/net/tun -v /dev/kvm:/dev/kvm
    needs: [validate]
    strategy:
      fail-fast: false
      matrix:
        machine: [imx8mm-jaguar-sentai, imx93-jaguar-eink]
        target: [lmp-factory-image, mfgtool-files]
    
    env:
      KAS_MACHINE: ${{ matrix.machine }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Setup build cache
        run: |
          echo "ðŸ—„ï¸ Setting up persistent build cache"
          mkdir -p ~/yocto/{downloads,sstate,persistent}
          chmod 755 ~/yocto/{downloads,sstate,persistent}

      - name: Build with KAS
        timeout-minutes: 360
        run: |
          echo "ðŸ”¨ Starting KAS build: ${{ matrix.machine }} (${{ matrix.target }})"
          
          # Select appropriate KAS configuration and build target
          if [ "${{ matrix.target }}" = "mfgtool-files" ]; then
            kas_config="kas/lmp-dynamicdevices-mfgtool.yml"
            build_target="mfgtool-files"
          else
            kas_config="kas/lmp-dynamicdevices-base.yml" 
            build_target="lmp-factory-image"
          fi
          
          echo "Using KAS config: $kas_config"
          echo "Build target: $build_target"
          echo "Machine: $KAS_MACHINE"
          
          # Run KAS build (directly in container)
          kas build "$kas_config:$build_target"
          
          echo "âœ… Build completed successfully"

      - name: Collect build artifacts
        if: always()
        run: |
          echo "ðŸ“¦ Collecting build artifacts for ${{ matrix.machine }} (${{ matrix.target }})"
          
          # Create artifacts directory
          mkdir -p artifacts/${{ matrix.machine }}/${{ matrix.target }}
          
          # Find the deploy directory
          deploy_dir=$(find . -path "*/tmp*/deploy/images/${{ matrix.machine }}" -type d | head -1)
          
          if [ -d "$deploy_dir" ]; then
            echo "âœ… Found deploy directory: $deploy_dir"
            
            # Copy key artifacts based on target
            if [ "${{ matrix.target }}" = "lmp-factory-image" ]; then
              # Factory image artifacts
              for pattern in "*.wic.gz" "*.wic.bmap" "imx-boot-*" "u-boot-*.itb"; do
                find "$deploy_dir" -name "$pattern" -exec cp {} artifacts/${{ matrix.machine }}/${{ matrix.target }}/ \; 2>/dev/null || true
              done
            else
              # MFGtool artifacts  
              for pattern in "imx-boot-mfgtool*" "u-boot-mfgtool*"; do
                find "$deploy_dir" -name "$pattern" -exec cp {} artifacts/${{ matrix.machine }}/${{ matrix.target }}/ \; 2>/dev/null || true
              done
            fi
            
            echo "ðŸ“‹ Artifacts collected:"
            ls -la artifacts/${{ matrix.machine }}/${{ matrix.target }}/
          else
            echo "âŒ Deploy directory not found"
            echo "# Build Failed" > artifacts/${{ matrix.machine }}/${{ matrix.target }}/build-failed.txt
          fi

      - name: Upload build artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: build-artifacts-${{ matrix.machine }}-${{ matrix.target }}
          path: artifacts/
          retention-days: 30
          if-no-files-found: warn

  # Summary job
  summary:
    name: Build Summary
    runs-on: self-hosted
    needs: [validate, build]
    if: always()
    
    steps:
      - name: Generate build summary
        run: |
          echo "# KAS Build CI Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Workflow:** ${{ github.workflow }}" >> $GITHUB_STEP_SUMMARY
          echo "**Trigger:** ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "**Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Determine overall status
          if [ "${{ needs.validate.result }}" = "success" ] && [ "${{ needs.build.result }}" = "success" ]; then
            echo "## âœ… Build Status: SUCCESS" >> $GITHUB_STEP_SUMMARY
            echo "All layer validations and builds completed successfully!" >> $GITHUB_STEP_SUMMARY
          else
            echo "## âŒ Build Status: FAILED" >> $GITHUB_STEP_SUMMARY
            echo "- Layer validation: ${{ needs.validate.result }}" >> $GITHUB_STEP_SUMMARY
            echo "- Build: ${{ needs.build.result }}" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Build Matrix" >> $GITHUB_STEP_SUMMARY
          echo "- **Machines:** imx8mm-jaguar-sentai, imx93-jaguar-eink" >> $GITHUB_STEP_SUMMARY
          echo "- **Targets:** lmp-factory-image, mfgtool-files" >> $GITHUB_STEP_SUMMARY
          echo "- **Total builds:** 4 (2 machines Ã— 2 targets)" >> $GITHUB_STEP_SUMMARY