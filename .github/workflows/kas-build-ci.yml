name: KAS Build CI

on:
  push:
    branches: [ main, develop ]
    paths:
      - 'recipes-**'
      - 'conf/**'
      - 'kas/**'
      - 'scripts/**'
      - 'classes/**'
      - '.github/workflows/kas-build-ci.yml'
  pull_request:
    branches: [ main, develop ]
    paths:
      - 'recipes-**'
      - 'conf/**'
      - 'kas/**'
      - 'scripts/**'
      - 'classes/**'
      - '.github/workflows/kas-build-ci.yml'
  workflow_dispatch:
    inputs:
      machine:
        description: 'Specific machine to build (optional - builds all if not specified)'
        required: false
        type: choice
        options:
          - 'all'
          - 'imx8mm-jaguar-sentai'
          - 'imx8mm-jaguar-inst'
          - 'imx8mm-jaguar-phasora'
          - 'imx8mm-jaguar-handheld'
          - 'imx93-jaguar-eink'

        default: 'all'

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # Job to determine which machines to build
  setup:
    runs-on: self-hosted
    outputs:
      machines: ${{ steps.machines.outputs.machines }}
      should_build: ${{ steps.changes.outputs.should_build }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check for relevant changes
        id: changes
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "should_build=true" >> $GITHUB_OUTPUT
          elif [ "${{ github.event_name }}" = "push" ] && [ "${{ github.ref }}" = "refs/heads/main" ]; then
            echo "should_build=true" >> $GITHUB_OUTPUT
          elif [ "${{ github.event_name }}" = "pull_request" ]; then
            # For PRs, check if any relevant files changed
            if git diff --name-only origin/main...HEAD | grep -E '^(recipes-|conf/|kas/|scripts/|classes/)'; then
              echo "should_build=true" >> $GITHUB_OUTPUT
            else
              echo "should_build=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "should_build=false" >> $GITHUB_OUTPUT
          fi

      - name: Determine machines to build
        id: machines
        run: |
          if [ "${{ github.event.inputs.machine }}" != "" ] && [ "${{ github.event.inputs.machine }}" != "all" ]; then
            echo "machines=[\"${{ github.event.inputs.machine }}\"]" >> $GITHUB_OUTPUT
          else
            echo 'machines=["imx8mm-jaguar-sentai","imx8mm-jaguar-inst","imx8mm-jaguar-phasora","imx8mm-jaguar-handheld","imx93-jaguar-eink"]' >> $GITHUB_OUTPUT
          fi

  # Validation job - quick checks before expensive builds
  validate:
    runs-on: self-hosted
    needs: setup
    if: needs.setup.outputs.should_build == 'true'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Docker for validation
        run: |
          # We'll use Docker containers for all operations, including validation
          # This avoids installing tools on the host runner
          echo "ðŸ³ Using Docker containers for validation and builds"
          
          # Verify Docker is available
          if ! command -v docker >/dev/null 2>&1; then
            echo "âŒ Docker not available on self-hosted runner"
            exit 1
          fi
          
          echo "âœ… Docker is available"
          docker --version

      - name: Validate KAS configurations
        run: |
          echo "ðŸ” Validating KAS configuration files..."
          
          # Check if required KAS files exist
          required_files=(
            "kas/lmp-dynamicdevices-base.yml"
            "kas/lmp-dynamicdevices-mfgtool.yml"
            "kas/base.yml"
            "kas/bsp.yml"
            "kas/dynamicdevices.yml"
          )
          
          for file in "${required_files[@]}"; do
            if [ ! -f "$file" ]; then
              echo "âŒ Missing required KAS file: $file"
              exit 1
            else
              echo "âœ… Found: $file"
            fi
          done

      - name: Validate machine configurations
        run: |
          echo "ðŸ” Validating machine configuration files..."
          
          machines='${{ needs.setup.outputs.machines }}'
          echo "Machines to validate: $machines"
          
          # Use Docker with jq to parse JSON (no host installation needed)
          machine_list=$(echo "$machines" | docker run --rm -i alpine/jq -r '.[]')
          
          for machine in $machine_list; do
            conf_file="conf/machine/${machine}.conf"
            if [ ! -f "$conf_file" ]; then
              echo "âŒ Missing machine config: $conf_file"
              exit 1
            else
              echo "âœ… Found machine config: $conf_file"
            fi
          done

      - name: Lint scripts
        run: |
          echo "ðŸ” Linting shell scripts with Docker..."
          
          # Use shellcheck via Docker container (no host installation needed)
          if find scripts/ -name "*.sh" | head -1 | grep -q "."; then
            echo "Running shellcheck on shell scripts..."
            find scripts/ -name "*.sh" -exec docker run --rm -v "$PWD:/mnt" koalaman/shellcheck:stable {} +
          else
            echo "âš ï¸ No shell scripts found to lint"
          fi

  # Main build job with matrix strategy
  build:
    runs-on: self-hosted
    needs: [setup, validate]
    if: needs.setup.outputs.should_build == 'true'
    strategy:
      fail-fast: false
      matrix:
        machine: ${{ fromJSON(needs.setup.outputs.machines) }}
        build_type: [base, mfgtool]
        # Build mfgtool for all machines - needed for board programming
    
    env:
      KAS_MACHINE: ${{ matrix.machine }}
      BUILD_TYPE: ${{ matrix.build_type }}
    
    steps:
      - name: Clean up workspace for self-hosted runner
        run: |
          echo "ðŸ§¹ Cleaning up workspace for self-hosted runner"
          # Clean up any previous build artifacts to free space
          if [ -d "${{ github.workspace }}" ]; then
            cd "${{ github.workspace }}"
            # Remove any large build directories from previous runs
            rm -rf build tmp-glibc deploy artifacts programming-packages || true
            # Clean docker containers and images if any
            docker system prune -f || true
          fi

      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Setup Docker environment for Yocto builds
        run: |
          echo "ðŸ³ Setting up Docker environment for Yocto builds"
          
          # Verify Docker is available on self-hosted runner
          if ! command -v docker >/dev/null 2>&1; then
            echo "âŒ Docker not available on self-hosted runner"
            exit 1
          fi
          
          echo "âœ… Docker is available"
          docker --version
          
          # Download kas-container script (minimal host dependency)
          if ! command -v kas-container >/dev/null 2>&1; then
            echo "ðŸ“¥ Downloading kas-container script..."
            wget -O kas-container https://raw.githubusercontent.com/siemens/kas/master/kas-container
            chmod +x kas-container
            # Add to PATH for this workflow
            echo "$PWD" >> $GITHUB_PATH
          else
            echo "âœ… kas-container already available"
          fi
          
          # Test kas-container works with Docker
          echo "ðŸ§ª Testing kas-container with Docker..."
          ./kas-container --help > /dev/null
          echo "âœ… kas-container is ready"

      - name: Setup persistent cache for Docker builds
        run: |
          echo "ðŸ—„ï¸ Setting up persistent build cache for Docker-based Yocto builds"
          
          # Use a persistent cache directory on the self-hosted runner
          # This will be mounted into the Docker container by kas-container
          CACHE_BASE="$HOME/yocto-cache"
          BUILD_DIR="$HOME/yocto-builds"
          
          # Create persistent cache and build directories
          mkdir -p "$CACHE_BASE"/{downloads,sstate}
          mkdir -p "$BUILD_DIR"
          
          echo "ðŸ“Š Cache directory sizes:"
          du -sh "$CACHE_BASE"/* 2>/dev/null || echo "Cache directories are empty (first run)"
          
          echo "ðŸ—ï¸ Build directory:"
          ls -la "$BUILD_DIR" 2>/dev/null || echo "Build directory is empty (first run)"
          
          # Export paths for kas-container to use
          echo "KAS_WORK_DIR=$BUILD_DIR" >> $GITHUB_ENV
          echo "DL_DIR=$CACHE_BASE/downloads" >> $GITHUB_ENV
          echo "SSTATE_DIR=$CACHE_BASE/sstate" >> $GITHUB_ENV
          
          echo "âœ… Docker build environment configured:"
          echo "   Work dir: $BUILD_DIR"
          echo "   Downloads: $CACHE_BASE/downloads"
          echo "   SSstate: $CACHE_BASE/sstate"

      - name: Set up build environment for self-hosted runner
        run: |
          echo "ðŸš€ Setting up build environment for ${{ matrix.machine }} (${{ matrix.build_type }})"
          
          # Create yocto cache directories (persistent symlinks already created)
          mkdir -p ~/yocto/persistent
          chmod 755 ~/yocto/persistent
          
          # Detect available CPU cores for optimal parallel builds
          NPROC=$(nproc)
          # Use 75% of available cores to leave some for system
          BUILD_THREADS=$((NPROC * 3 / 4))
          BUILD_THREADS=${BUILD_THREADS:-4}  # Minimum 4 threads
          
          echo "ðŸ–¥ï¸ Self-hosted runner specs:"
          echo "  CPU cores: $NPROC"
          echo "  Build threads: $BUILD_THREADS"
          echo "  RAM: $(free -h | awk '/^Mem:/ {print $2}')"
          echo "  Disk space: $(df -h . | awk 'NR==2 {print $4}')"
          
          # Set optimized environment variables for self-hosted runner
          echo "BB_NUMBER_THREADS=$BUILD_THREADS" >> $GITHUB_ENV
          echo "PARALLEL_MAKE=-j$BUILD_THREADS" >> $GITHUB_ENV
          
          # Disable interactive features
          echo "DEBIAN_FRONTEND=noninteractive" >> $GITHUB_ENV
          
          # For development builds, disable signing to avoid key issues
          echo "OPTEE_TA_SIGN_ENABLE=0" >> $GITHUB_ENV
          echo "SIGN_ENABLE=0" >> $GITHUB_ENV
          echo "UBOOT_SIGN_ENABLE=0" >> $GITHUB_ENV
          echo "UBOOT_SPL_SIGN_ENABLE=0" >> $GITHUB_ENV
          echo "TF_A_SIGN_ENABLE=0" >> $GITHUB_ENV
          echo "UEFI_SIGN_ENABLE=0" >> $GITHUB_ENV

      - name: Build with KAS
        timeout-minutes: 240  # 4 hour timeout
        run: |
          echo "ðŸ”¨ Starting KAS build: ${{ matrix.machine }} (${{ matrix.build_type }})"
          
          # Select appropriate KAS configuration
          if [ "${{ matrix.build_type }}" = "mfgtool" ]; then
            kas_config="kas/lmp-dynamicdevices-mfgtool.yml"
          else
            kas_config="kas/lmp-dynamicdevices-base.yml"
          fi
          
          echo "Using KAS config: $kas_config"
          echo "Machine: $KAS_MACHINE"
          
          # Run KAS build in Docker container (all tools and dependencies included)
          kas-container \
            --runtime-args "-v $DL_DIR:/downloads \
                           -v $SSTATE_DIR:/sstate \
                           -e KAS_MACHINE=$KAS_MACHINE \
                           -e DL_DIR=/downloads \
                           -e SSTATE_DIR=/sstate \
                           -e BB_NUMBER_THREADS=$BB_NUMBER_THREADS \
                           -e PARALLEL_MAKE='$PARALLEL_MAKE' \
                           -e OPTEE_TA_SIGN_ENABLE=$OPTEE_TA_SIGN_ENABLE \
                           -e SIGN_ENABLE=$SIGN_ENABLE \
                           -e UBOOT_SIGN_ENABLE=$UBOOT_SIGN_ENABLE \
                           -e UBOOT_SPL_SIGN_ENABLE=$UBOOT_SPL_SIGN_ENABLE \
                           -e TF_A_SIGN_ENABLE=$TF_A_SIGN_ENABLE \
                           -e UEFI_SIGN_ENABLE=$UEFI_SIGN_ENABLE" \
            build "$kas_config"

      - name: Collect build artifacts
        if: always()
        run: |
          echo "ðŸ“¦ Collecting build artifacts for ${{ matrix.machine }} (${{ matrix.build_type }})"
          
          # Create artifacts directories
          mkdir -p artifacts/${{ matrix.machine }}/${{ matrix.build_type }}
          mkdir -p programming-packages/${{ matrix.machine }}
          
          # Define deploy directory (inside the kas work directory)
          deploy_dir="$KAS_WORK_DIR/build/tmp/deploy/images/${{ matrix.machine }}"
          
          if [ -d "$deploy_dir" ]; then
            echo "âœ… Deploy directory found: $deploy_dir"
            
            # Copy all build artifacts
            artifacts=(
              "*.wic.gz"
              "*.wic.bmap"
              "imx-boot-*"
              "u-boot-*.itb"
              "*.dtb"
            )
            
            for pattern in "${artifacts[@]}"; do
              if ls "$deploy_dir"/$pattern 1> /dev/null 2>&1; then
                cp "$deploy_dir"/$pattern artifacts/${{ matrix.machine }}/${{ matrix.build_type }}/
                echo "ðŸ“ Copied to artifacts: $pattern"
              fi
            done
            
            # Create board-specific programming package
            if [ "${{ matrix.build_type }}" = "base" ]; then
              echo "ðŸ“¦ Creating programming package for ${{ matrix.machine }}"
              
              # Files needed for UUU programming (from program_full_image.uuu.in)
              programming_files=(
                "lmp-factory-image-${{ matrix.machine }}.wic.gz"
                "imx-boot-${{ matrix.machine }}"
                "u-boot-${{ matrix.machine }}.itb"
              )
              
              # Copy programming files
              for file in "${programming_files[@]}"; do
                if [ -f "$deploy_dir/$file" ]; then
                  cp "$deploy_dir/$file" programming-packages/${{ matrix.machine }}/
                  echo "ðŸ“‹ Added to programming package: $file"
                else
                  echo "âš ï¸  Programming file not found: $file"
                fi
              done
              
              # Note: mfgtool files will be added by the mfgtool build job
              echo "ðŸ“‹ Base build complete - mfgtool files will be added by mfgtool build"
            elif [ "${{ matrix.build_type }}" = "mfgtool" ]; then
              echo "ðŸ“¦ Adding mfgtool files to programming package for ${{ matrix.machine }}"
              
              # Mfgtool files needed for UUU programming  
              mfgtool_files=(
                "imx-boot-mfgtool"
                "u-boot-mfgtool.itb"
              )
              
              # Add mfgtool files to existing programming package
              for file in "${mfgtool_files[@]}"; do
                if [ -f "$deploy_dir/$file" ]; then
                  cp "$deploy_dir/$file" programming-packages/${{ matrix.machine }}/
                  echo "ðŸ“‹ Added mfgtool file: $file"
                else
                  echo "âš ï¸  Mfgtool file not found: $file"
                fi
              done
              
              # Update the programming script to indicate mfgtool files are now available
              if [ -f "programming-packages/${{ matrix.machine }}/program-${{ matrix.machine }}.sh" ]; then
                echo "ðŸ“‹ Mfgtool files added to existing programming package"
              else
                echo "âš ï¸  Programming package not found - base build may have failed"
              fi
              
              # Create programming script for this machine
              cat > programming-packages/${{ matrix.machine }}/program-${{ matrix.machine }}.sh << 'EOF'
          #!/bin/bash
          # Board Programming Script for ${{ matrix.machine }}
          # Generated automatically by CI build
          
          set -e
          
          MACHINE="${{ matrix.machine }}"
          SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
          
          echo "ðŸš€ Programming $MACHINE board..."
          echo "ðŸ“ Using files from: $SCRIPT_DIR"
          
          # Verify required files exist
          required_files=(
              "imx-boot-mfgtool"
              "u-boot-mfgtool.itb"
              "lmp-factory-image-$MACHINE.wic.gz"
              "imx-boot-$MACHINE"
              "u-boot-$MACHINE.itb"
          )
          
          for file in "${required_files[@]}"; do
              if [ ! -f "$SCRIPT_DIR/$file" ]; then
                  echo "âŒ Required file missing: $file"
                  exit 1
              fi
          done
          
          # Create UUU script
          cat > "$SCRIPT_DIR/program_$MACHINE.uuu" << UUU_EOF
          uuu_version 1.2.39
          
          SDP: boot -f imx-boot-mfgtool
          
          SDPV: delay 1000
          SDPV: write -f u-boot-mfgtool.itb
          SDPV: jump
          
          FB: ucmd setenv fastboot_dev mmc
          FB: ucmd setenv mmcdev \${emmc_dev}
          FB: ucmd mmc dev \${emmc_dev} 1; mmc erase 0 0x2000
          FB: flash -raw2sparse all lmp-factory-image-$MACHINE.wic.gz/*
          FB: flash bootloader imx-boot-$MACHINE
          FB: flash bootloader2 u-boot-$MACHINE.itb
          FB: flash bootloader_s imx-boot-$MACHINE
          FB: flash bootloader2_s u-boot-$MACHINE.itb
          FB: ucmd if env exists emmc_ack; then ; else setenv emmc_ack 0; fi;
          FB: ucmd mmc partconf \${emmc_dev} \${emmc_ack} 1 0
          FB: done
          UUU_EOF
          
          echo "âœ… Created UUU script: program_$MACHINE.uuu"
          echo "ðŸ”Œ Connect board in download mode and run:"
          echo "   sudo uuu program_$MACHINE.uuu"
          
          # Optionally run UUU if requested
          if [ "${1:-}" = "--flash" ]; then
              echo "ðŸš€ Starting board programming..."
              sudo uuu "program_$MACHINE.uuu"
          fi
          EOF
              
              chmod +x programming-packages/${{ matrix.machine }}/program-${{ matrix.machine }}.sh
              
              # Create README for programming package
              cat > programming-packages/${{ matrix.machine }}/README.md << 'EOF'
          # Programming Package for ${{ matrix.machine }}
          
          **Generated**: $(date)  
          **Commit**: ${{ github.sha }}  
          **Branch**: ${{ github.ref_name }}
          
          ## Files Included
          
          ### Bootloaders
          - `imx-boot-mfgtool` - Manufacturing tool bootloader
          - `u-boot-mfgtool.itb` - Manufacturing tool U-Boot
          - `imx-boot-${{ matrix.machine }}` - Production bootloader  
          - `u-boot-${{ matrix.machine }}.itb` - Production U-Boot
          
          ### System Image
          - `lmp-factory-image-${{ matrix.machine }}.wic.gz` - Complete system image
          
          ### Programming Tools
          - `program-${{ matrix.machine }}.sh` - Automated programming script
          - `program_${{ matrix.machine }}.uuu` - UUU programming script (auto-generated)
          
          ## Usage
          
          ### Prerequisites
          - Install NXP UUU tool
          - Connect ${{ matrix.machine }} board via USB in download mode
          
          ### Programming Steps
          
          1. **Put board in download mode**
          2. **Connect USB cable**
          3. **Run programming script**:
             ```bash
             ./program-${{ matrix.machine }}.sh --flash
             ```
          
          ### Manual Programming
          
          If you prefer manual control:
          ```bash
          sudo uuu program_${{ matrix.machine }}.uuu
          ```
          
          ## Board-Specific Notes
          
          - **Machine**: ${{ matrix.machine }}
          - **Architecture**: $(echo "${{ matrix.machine }}" | grep -q "imx8mm" && echo "i.MX8M Mini" || echo "i.MX93")
          - **Board Type**: $(echo "${{ matrix.machine }}" | sed 's/.*jaguar-//' | tr '[:lower:]' '[:upper:]')
          
          EOF
            fi
            
            # Create build artifact summary
            echo "# Build Artifacts for ${{ matrix.machine }} (${{ matrix.build_type }})" > artifacts/${{ matrix.machine }}/${{ matrix.build_type }}/README.md
            echo "Generated on: $(date)" >> artifacts/${{ matrix.machine }}/${{ matrix.build_type }}/README.md
            echo "Commit: ${{ github.sha }}" >> artifacts/${{ matrix.machine }}/${{ matrix.build_type }}/README.md
            echo "" >> artifacts/${{ matrix.machine }}/${{ matrix.build_type }}/README.md
            echo "## Files:" >> artifacts/${{ matrix.machine }}/${{ matrix.build_type }}/README.md
            
            cd artifacts/${{ matrix.machine }}/${{ matrix.build_type }}
            for file in *; do
              if [ "$file" != "README.md" ]; then
                size=$(du -h "$file" | cut -f1)
                echo "- $file ($size)" >> README.md
              fi
            done
            cd ../../../
            
          else
            echo "âŒ Deploy directory not found: $deploy_dir"
            echo "Available directories in kas work dir:"
            ls -la "$KAS_WORK_DIR/build/tmp/deploy/" 2>/dev/null || echo "No deploy directory found"
            echo "Available directories in kas work dir build:"
            ls -la "$KAS_WORK_DIR/build/" 2>/dev/null || echo "No build directory found"
          fi

      - name: Upload build artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: build-artifacts-${{ matrix.machine }}-${{ matrix.build_type }}
          path: artifacts/
          retention-days: 30
          if-no-files-found: warn

      - name: Upload programming packages
        if: always() && matrix.build_type == 'base'
        uses: actions/upload-artifact@v4
        with:
          name: programming-package-${{ matrix.machine }}
          path: programming-packages/${{ matrix.machine }}/
          retention-days: 90
          if-no-files-found: warn

      - name: Generate build report
        if: always()
        run: |
          echo "ðŸ“Š Generating build report"
          
          # Create build report
          cat > build-report-${{ matrix.machine }}-${{ matrix.build_type }}.md << EOF
          # Build Report: ${{ matrix.machine }} (${{ matrix.build_type }})
          
          **Date:** $(date)
          **Commit:** ${{ github.sha }}
          **Branch:** ${{ github.ref_name }}
          **Workflow:** ${{ github.workflow }}
          **Run:** ${{ github.run_number }}
          
          ## Build Configuration
          - **Machine:** ${{ matrix.machine }}
          - **Build Type:** ${{ matrix.build_type }}
          - **KAS Configuration:** $([ "${{ matrix.build_type }}" = "mfgtool" ] && echo "kas/lmp-dynamicdevices-mfgtool.yml" || echo "kas/lmp-dynamicdevices-base.yml")
          
          ## Build Status
          - **Status:** ${{ job.status }}
          - **Duration:** \$(expr \$SECONDS / 60) minutes
          
          ## Build Environment
          - **Runner:** ubuntu-latest
          - **Parallel Jobs:** \$BB_NUMBER_THREADS
          - **Make Jobs:** \$PARALLEL_MAKE
          
          ## Security Configuration
          - **Signing Disabled:** Development build (CI environment)
          
          EOF
          
          # Check if artifacts were created
          if [ -d "artifacts/${{ matrix.machine }}/${{ matrix.build_type }}" ]; then
            echo "## Artifacts Generated" >> build-report-${{ matrix.machine }}-${{ matrix.build_type }}.md
            echo "âœ… Build artifacts available for download" >> build-report-${{ matrix.machine }}-${{ matrix.build_type }}.md
          else
            echo "## Artifacts" >> build-report-${{ matrix.machine }}-${{ matrix.build_type }}.md
            echo "âŒ No artifacts generated" >> build-report-${{ matrix.machine }}-${{ matrix.build_type }}.md
          fi

      - name: Upload build report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: build-report-${{ matrix.machine }}-${{ matrix.build_type }}
          path: build-report-${{ matrix.machine }}-${{ matrix.build_type }}.md
          retention-days: 90

  # Create final programming packages combining base + mfgtool artifacts
  create-programming-packages:
    runs-on: self-hosted
    needs: [setup, build]
    if: always() && needs.setup.outputs.should_build == 'true'
    strategy:
      matrix:
        machine: ${{ fromJSON(needs.setup.outputs.machines) }}
    steps:
      - name: Download base build artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-artifacts-${{ matrix.machine }}-base
          path: base-artifacts/
        continue-on-error: true

      - name: Download mfgtool build artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-artifacts-${{ matrix.machine }}-mfgtool
          path: mfgtool-artifacts/
        continue-on-error: true

      - name: Create complete programming package
        run: |
          echo "ðŸ“¦ Creating complete programming package for ${{ matrix.machine }}"
          
          # Create programming package directory
          mkdir -p programming-packages/${{ matrix.machine }}
          
          # Copy base build files if available
          if [ -d "base-artifacts/${{ matrix.machine }}/base" ]; then
            echo "ðŸ“‹ Adding base build files..."
            
            # Files needed for UUU programming
            base_files=(
              "lmp-factory-image-${{ matrix.machine }}.wic.gz"
              "imx-boot-${{ matrix.machine }}"
              "u-boot-${{ matrix.machine }}.itb"
            )
            
            for file in "${base_files[@]}"; do
              if [ -f "base-artifacts/${{ matrix.machine }}/base/$file" ]; then
                cp "base-artifacts/${{ matrix.machine }}/base/$file" "programming-packages/${{ matrix.machine }}/"
                echo "âœ… Added: $file"
              else
                echo "âš ï¸  Missing base file: $file"
              fi
            done
          else
            echo "âŒ Base build artifacts not found"
          fi
          
          # Copy mfgtool files if available
          if [ -d "mfgtool-artifacts/${{ matrix.machine }}/mfgtool" ]; then
            echo "ðŸ“‹ Adding mfgtool files..."
            
            # Mfgtool files
            mfgtool_files=(
              "imx-boot-mfgtool"
              "u-boot-mfgtool.itb"
            )
            
            for file in "${mfgtool_files[@]}"; do
              if [ -f "mfgtool-artifacts/${{ matrix.machine }}/mfgtool/$file" ]; then
                cp "mfgtool-artifacts/${{ matrix.machine }}/mfgtool/$file" "programming-packages/${{ matrix.machine }}/"
                echo "âœ… Added: $file"
              else
                echo "âš ï¸  Missing mfgtool file: $file"
              fi
            done
          else
            echo "âŒ Mfgtool build artifacts not found"
          fi
          
          # Create programming script
          cat > programming-packages/${{ matrix.machine }}/program-${{ matrix.machine }}.sh << 'EOF'
          #!/bin/bash
          # Board Programming Script for ${{ matrix.machine }}
          # Generated automatically by CI build
          
          set -e
          
          MACHINE="${{ matrix.machine }}"
          SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
          
          echo "ðŸš€ Programming $MACHINE board..."
          echo "ðŸ“ Using files from: $SCRIPT_DIR"
          
          # Verify required files exist
          required_files=(
              "imx-boot-mfgtool"
              "u-boot-mfgtool.itb"
              "lmp-factory-image-$MACHINE.wic.gz"
              "imx-boot-$MACHINE"
              "u-boot-$MACHINE.itb"
          )
          
          missing_files=()
          for file in "${required_files[@]}"; do
              if [ ! -f "$SCRIPT_DIR/$file" ]; then
                  missing_files+=("$file")
              fi
          done
          
          if [ ${#missing_files[@]} -gt 0 ]; then
              echo "âŒ Missing required files:"
              printf '  - %s\n' "${missing_files[@]}"
              echo ""
              echo "Available files:"
              ls -la "$SCRIPT_DIR"
              exit 1
          fi
          
          echo "âœ… All required files present"
          
          # Create UUU script
          cat > "$SCRIPT_DIR/program_$MACHINE.uuu" << UUU_EOF
          uuu_version 1.2.39
          
          SDP: boot -f imx-boot-mfgtool
          
          SDPV: delay 1000
          SDPV: write -f u-boot-mfgtool.itb
          SDPV: jump
          
          FB: ucmd setenv fastboot_dev mmc
          FB: ucmd setenv mmcdev \${emmc_dev}
          FB: ucmd mmc dev \${emmc_dev} 1; mmc erase 0 0x2000
          FB: flash -raw2sparse all lmp-factory-image-$MACHINE.wic.gz/*
          FB: flash bootloader imx-boot-$MACHINE
          FB: flash bootloader2 u-boot-$MACHINE.itb
          FB: flash bootloader_s imx-boot-$MACHINE
          FB: flash bootloader2_s u-boot-$MACHINE.itb
          FB: ucmd if env exists emmc_ack; then ; else setenv emmc_ack 0; fi;
          FB: ucmd mmc partconf \${emmc_dev} \${emmc_ack} 1 0
          FB: done
          UUU_EOF
          
          echo "âœ… Created UUU script: program_$MACHINE.uuu"
          echo ""
          echo "ðŸ”Œ To program the board:"
          echo "  1. Put board in download mode"
          echo "  2. Connect USB cable"
          echo "  3. Run: sudo uuu program_$MACHINE.uuu"
          echo ""
          echo "Or use this script with --flash to program automatically:"
          echo "  ./program-$MACHINE.sh --flash"
          
          # Optionally run UUU if requested
          if [ "${1:-}" = "--flash" ]; then
              echo "ðŸš€ Starting board programming..."
              if command -v uuu >/dev/null 2>&1; then
                  sudo uuu "program_$MACHINE.uuu"
              else
                  echo "âŒ UUU tool not found. Please install NXP UUU tool first."
                  exit 1
              fi
          fi
          EOF
          
          chmod +x programming-packages/${{ matrix.machine }}/program-${{ matrix.machine }}.sh
          
          # Create comprehensive README
          cat > programming-packages/${{ matrix.machine }}/README.md << 'EOF'
          # Programming Package for ${{ matrix.machine }}
          
          **Generated**: $(date)  
          **Commit**: ${{ github.sha }}  
          **Branch**: ${{ github.ref_name }}  
          **Build Run**: ${{ github.run_number }}
          
          ## Files Included
          
          ### Manufacturing Tool Files (for board programming)
          - `imx-boot-mfgtool` - Manufacturing tool bootloader
          - `u-boot-mfgtool.itb` - Manufacturing tool U-Boot
          
          ### Production Files (to be programmed onto board)
          - `imx-boot-${{ matrix.machine }}` - Production bootloader for ${{ matrix.machine }}
          - `u-boot-${{ matrix.machine }}.itb` - Production U-Boot for ${{ matrix.machine }}
          - `lmp-factory-image-${{ matrix.machine }}.wic.gz` - Complete system image
          
          ### Programming Tools
          - `program-${{ matrix.machine }}.sh` - Automated programming script
          - `program_${{ matrix.machine }}.uuu` - UUU programming script (auto-generated)
          
          ## Prerequisites
          
          - **NXP UUU Tool**: Install from https://github.com/nxp-imx/mfgtools
          - **USB Connection**: Connect board to host via USB
          - **Download Mode**: Board must be in download/recovery mode
          
          ## Quick Start
          
          1. **Install UUU** (if not already installed):
             ```bash
             # Ubuntu/Debian
             sudo apt install uuu
             
             # Or download from GitHub releases
             wget https://github.com/nxp-imx/mfgtools/releases/latest/download/uuu
             chmod +x uuu
             sudo mv uuu /usr/local/bin/
             ```
          
          2. **Put board in download mode**:
             - Power off the board
             - Set boot switches for download mode (see board manual)
             - Connect USB cable between board and host
             - Power on the board
          
          3. **Program the board**:
             ```bash
             ./program-${{ matrix.machine }}.sh --flash
             ```
          
          ## Manual Programming
          
          For more control over the programming process:
          ```bash
          sudo uuu program_${{ matrix.machine }}.uuu
          ```
          
          ## Board Information
          
          - **Machine**: ${{ matrix.machine }}
          - **Architecture**: $(echo "${{ matrix.machine }}" | grep -q "imx8mm" && echo "i.MX8M Mini" || echo "i.MX93")
          - **Board Type**: $(echo "${{ matrix.machine }}" | sed 's/.*jaguar-//' | tr '[:lower:]' '[:upper:]')
          
          ## Troubleshooting
          
          ### Board not detected
          - Verify USB connection
          - Check board is in download mode
          - Try different USB cable/port
          - Check `lsusb` for NXP device
          
          ### Programming fails
          - Ensure all files are present
          - Check file permissions
          - Verify UUU tool is latest version
          - Run with `sudo` privileges
          
          ### Recovery
          If programming fails partway through, the board should still be recoverable by repeating the process.
          
          EOF

      - name: Upload complete programming package
        uses: actions/upload-artifact@v4
        with:
          name: programming-package-${{ matrix.machine }}
          path: programming-packages/${{ matrix.machine }}/
          retention-days: 90
          if-no-files-found: warn

  # Summary job that creates overall build status
  summary:
    runs-on: self-hosted
    needs: [setup, build, create-programming-packages]
    if: always() && needs.setup.outputs.should_build == 'true'
    steps:
      - name: Generate build summary
        run: |
          echo "# KAS Build CI Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Workflow:** ${{ github.workflow }}" >> $GITHUB_STEP_SUMMARY
          echo "**Trigger:** ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "**Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Determine overall status
          if [ "${{ needs.build.result }}" = "success" ]; then
            echo "## âœ… Build Status: SUCCESS" >> $GITHUB_STEP_SUMMARY
            echo "All builds completed successfully!" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ needs.build.result }}" = "failure" ]; then
            echo "## âŒ Build Status: FAILURE" >> $GITHUB_STEP_SUMMARY
            echo "One or more builds failed. Check individual job logs for details." >> $GITHUB_STEP_SUMMARY
          else
            echo "## âš ï¸ Build Status: ${{ needs.build.result }}" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Build Matrix" >> $GITHUB_STEP_SUMMARY
          echo "Machines built: ${{ needs.setup.outputs.machines }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Artifacts" >> $GITHUB_STEP_SUMMARY
          echo "Build artifacts and reports are available in the workflow artifacts section." >> $GITHUB_STEP_SUMMARY

      - name: Update issue status
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        run: |
          echo "Updating GitHub issue #14 with CI status"
          # This would update the issue, but requires GitHub token with appropriate permissions
          # For now, just log the intent
          echo "CI build completed with status: ${{ needs.build.result }}"
