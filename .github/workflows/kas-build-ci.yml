name: KAS Build CI

on:
  push:
    branches: [ main, develop ]
    paths:
      - 'recipes-**'
      - 'conf/**'
      - 'kas/**'
      - 'scripts/**'
      - 'classes/**'
      - '.github/workflows/kas-build-ci.yml'
  pull_request:
    branches: [ main, develop ]
    paths:
      - 'recipes-**'
      - 'conf/**'
      - 'kas/**'
      - 'scripts/**'
      - 'classes/**'
      - '.github/workflows/kas-build-ci.yml'
  workflow_dispatch:
    inputs:
      machine:
        description: 'Specific machine to build (optional - builds all active machines if not specified)'
        required: false
        type: choice
        options:
          - 'all'
          - 'imx8mm-jaguar-sentai'
          - 'imx93-jaguar-eink'
          # Temporarily disabled:
          # - 'imx8mm-jaguar-inst'
          # - 'imx8mm-jaguar-phasora'
          # - 'imx8mm-jaguar-handheld'

        default: 'all'

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # Job to determine which machines to build
  setup:
    runs-on: self-hosted
    outputs:
      machines: ${{ steps.machines.outputs.machines }}
      should_build: ${{ steps.changes.outputs.should_build }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check for relevant changes
        id: changes
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "should_build=true" >> $GITHUB_OUTPUT
          elif [ "${{ github.event_name }}" = "push" ] && [ "${{ github.ref }}" = "refs/heads/main" ]; then
            echo "should_build=true" >> $GITHUB_OUTPUT
          elif [ "${{ github.event_name }}" = "pull_request" ]; then
            # For PRs, check if any relevant files changed
            if git diff --name-only origin/main...HEAD | grep -E '^(recipes-|conf/|kas/|scripts/|classes/)'; then
              echo "should_build=true" >> $GITHUB_OUTPUT
            else
              echo "should_build=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "should_build=false" >> $GITHUB_OUTPUT
          fi

      - name: Determine machines to build
        id: machines
        run: |
          if [ "${{ github.event.inputs.machine }}" != "" ] && [ "${{ github.event.inputs.machine }}" != "all" ]; then
            echo "machines=[\"${{ github.event.inputs.machine }}\"]" >> $GITHUB_OUTPUT
          else
            # Temporarily disabled: imx8mm-jaguar-inst, imx8mm-jaguar-phasora, imx8mm-jaguar-handheld
            echo 'machines=["imx8mm-jaguar-sentai","imx93-jaguar-eink"]' >> $GITHUB_OUTPUT
          fi

  # Validation job - quick checks before expensive builds
  validate:
    runs-on: self-hosted
    needs: setup
    if: needs.setup.outputs.should_build == 'true'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Docker for validation
        run: |
          # We'll use Docker containers for all operations, including validation
          # This avoids installing tools on the host runner
          echo "üê≥ Using Docker containers for validation and builds"
          
          # Verify Docker is available
          if ! command -v docker >/dev/null 2>&1; then
            echo "‚ùå Docker not available on self-hosted runner"
            exit 1
          fi
          
          echo "‚úÖ Docker is available"
          docker --version
          
          # Install kas-container for Yocto validation
          echo "üì¶ Installing kas-container for Yocto validation..."
          if ! command -v kas-container >/dev/null 2>&1; then
            # Download kas-container script
            curl -o kas-container https://raw.githubusercontent.com/siemens/kas/master/kas-container
            chmod +x kas-container
            # Add to PATH for this job
            echo "$PWD" >> $GITHUB_PATH
            echo "‚úÖ kas-container installed"
          else
            echo "‚úÖ kas-container already available"
          fi

      - name: Validate KAS configurations
        run: |
          echo "üîç Validating KAS configuration files..."
          
          # Check if required KAS files exist
          required_files=(
            "kas/lmp-dynamicdevices-base.yml"
            "kas/lmp-dynamicdevices-mfgtool.yml"
            "kas/base.yml"
            "kas/bsp.yml"
            "kas/dynamicdevices.yml"
          )
          
          for file in "${required_files[@]}"; do
            if [ ! -f "$file" ]; then
              echo "‚ùå Missing required KAS file: $file"
              exit 1
            else
              echo "‚úÖ Found: $file"
            fi
          done

      - name: Validate machine configurations
        run: |
          echo "üîç Validating machine configuration files..."
          
          machines='${{ needs.setup.outputs.machines }}'
          echo "Machines to validate: $machines"
          
          # Parse JSON manually to avoid Docker complexity in validation
          # Extract machine names from JSON array format like ["machine1","machine2"]
          machine_list=$(echo "$machines" | sed 's/\[//g' | sed 's/\]//g' | sed 's/"//g' | tr ',' '\n')
          
          for machine in $machine_list; do
            # Trim whitespace
            machine=$(echo "$machine" | xargs)
            if [ -n "$machine" ]; then
              conf_file="conf/machine/${machine}.conf"
              if [ ! -f "$conf_file" ]; then
                echo "‚ùå Missing machine config: $conf_file"
                exit 1
              else
                echo "‚úÖ Found machine config: $conf_file"
              fi
            fi
          done

      - name: Lint scripts
        run: |
          echo "üîç Linting shell scripts with Docker..."
          
          # Use shellcheck via Docker container (no host installation needed)
          if find scripts/ -name "*.sh" -print -quit | grep -q .; then
            echo "Running shellcheck on shell scripts..."
            # Run shellcheck on each script individually to avoid path issues
            find scripts/ -name "*.sh" -exec bash -c 'docker run --rm -v "$PWD:/mnt" koalaman/shellcheck:stable "/mnt/$1"' _ {} \;
          else
            echo "‚ö†Ô∏è No shell scripts found to lint"
          fi

      - name: Validate Yocto recipes
        run: |
          echo "üîç Validating Yocto recipes and configurations..."
          
          # Check for common Yocto recipe issues
          echo "Checking for recipe syntax issues..."
          
          # Initialize counters
          total_files=0
          issues_found=0
          
          # Check .bb and .bbappend files for common issues
          while IFS= read -r -d '' file; do
            total_files=$((total_files + 1))
            echo "üìã Checking: $file"
            
            # Check for common syntax issues
            if grep -n "^[[:space:]]*=" "$file" >/dev/null 2>&1; then
              echo "  ‚ö†Ô∏è  Potential assignment issue (line starts with whitespace + =)"
              grep -n "^[[:space:]]*=" "$file" | head -3 | sed 's/^/    /' || true
              issues_found=$((issues_found + 1))
            fi
            
            # Check for tabs vs spaces consistency
            if grep -P "\t" "$file" >/dev/null 2>&1 && grep "^    " "$file" >/dev/null 2>&1; then
              echo "  ‚ö†Ô∏è  Mixed tabs and spaces detected"
              issues_found=$((issues_found + 1))
            fi
            
            # Check for trailing whitespace
            if grep -n "[[:space:]]$" "$file" >/dev/null 2>&1; then
              trailing_count=$(grep -c "[[:space:]]$" "$file" || echo "0")
              echo "  ‚ö†Ô∏è  Trailing whitespace found ($trailing_count lines)"
              grep -n "[[:space:]]$" "$file" | head -3 | sed 's/^/    /' || true
              issues_found=$((issues_found + 1))
            fi
            
            # Check for proper SRC_URI format
            if grep -q "SRC_URI.*=" "$file" 2>/dev/null; then
              if grep "SRC_URI.*=" "$file" | grep -v "file://" | grep -v "git://" | grep -v "https://" | grep -v "http://" | grep -v "ftp://" >/dev/null 2>&1; then
                echo "  ‚ö†Ô∏è  Potential SRC_URI format issue detected"
                grep -n "SRC_URI.*=" "$file" | head -2 | sed 's/^/    /' || true
                issues_found=$((issues_found + 1))
              fi
            fi
            
          done < <(find recipes* bbappends* conf/ -name "*.bb" -o -name "*.bbappend" -o -name "*.conf" -print0 2>/dev/null)
          
          echo ""
          echo "üìä Yocto recipe validation summary:"
          echo "  Files checked: $total_files"
          echo "  Issues found: $issues_found"
          
          if [ $issues_found -eq 0 ]; then
            echo "‚úÖ Yocto recipe validation complete - no issues found"
          else
            echo "‚ö†Ô∏è  Yocto recipe validation complete - $issues_found issues found"
          fi

      - name: Check layer compatibility
        run: |
          echo "üîç Checking layer compatibility and dependencies..."
          
          # Initialize counters
          layer_files=0
          layer_issues=0
          recipe_files=0
          circular_deps=0
          
          # Validate layer.conf files
          echo "üìã Validating layer configuration files..."
          while IFS= read -r -d '' layerconf; do
            layer_files=$((layer_files + 1))
            echo "  Checking: $layerconf"
            
            # Check for required variables
            for var in BBPATH BBFILES BBFILE_COLLECTIONS; do
              if ! grep -q "^$var" "$layerconf"; then
                echo "    ‚ö†Ô∏è  Missing required variable: $var"
                layer_issues=$((layer_issues + 1))
              fi
            done
            
            # Check for proper priority setting
            if ! grep -q "BBFILE_PRIORITY" "$layerconf"; then
              echo "    ‚ö†Ô∏è  Missing BBFILE_PRIORITY setting"
              layer_issues=$((layer_issues + 1))
            fi
            
          done < <(find . -name "layer.conf" -print0 2>/dev/null)
          
          # Check for circular dependencies in .bb files
          echo ""
          echo "üîÑ Checking for potential circular dependencies..."
          while IFS= read -r -d '' recipe; do
            recipe_files=$((recipe_files + 1))
            
            # Extract package name from filename
            pkg_name=$(basename "$recipe" | sed 's/_.*\.bb.*//')
            
            # Check for actual circular dependencies (DEPENDS on exact same package name)
            # Exclude RDEPENDS lines as they often reference sub-packages legitimately
            if grep -E "^[[:space:]]*DEPENDS[[:space:]]*[+:=].*[[:space:]]${pkg_name}[[:space:]]*$" "$recipe" 2>/dev/null; then
              echo "  ‚ö†Ô∏è  Potential circular dependency in: $recipe"
              echo "    Package '$pkg_name' may depend on itself in DEPENDS"
              grep -E "^[[:space:]]*DEPENDS[[:space:]]*[+:=].*[[:space:]]${pkg_name}[[:space:]]*$" "$recipe" | sed 's/^/      /'
              circular_deps=$((circular_deps + 1))
            fi
            
            # Check for obvious self-references in DEPENDS (but not RDEPENDS)
            if grep -E "^[[:space:]]*DEPENDS[[:space:]]*[+:=].*[\"']${pkg_name}[\"']" "$recipe" 2>/dev/null; then
              echo "  ‚ö†Ô∏è  Potential circular dependency in: $recipe"
              echo "    Package '$pkg_name' explicitly depends on itself"
              grep -E "^[[:space:]]*DEPENDS[[:space:]]*[+:=].*[\"']${pkg_name}[\"']" "$recipe" | sed 's/^/      /'
              circular_deps=$((circular_deps + 1))
            fi
            
          done < <(find recipes* bbappends* -name "*.bb" -o -name "*.bbappend" -print0 2>/dev/null)
          
          echo ""
          echo "üìä Layer compatibility summary:"
          echo "  Layer files checked: $layer_files"
          echo "  Layer configuration issues: $layer_issues"
          echo "  Recipe files checked: $recipe_files"
          echo "  Circular dependencies found: $circular_deps"
          
          total_issues=$((layer_issues + circular_deps))
          if [ $total_issues -eq 0 ]; then
            echo "‚úÖ Layer compatibility check complete - no issues found"
          else
            echo "‚ö†Ô∏è  Layer compatibility check complete - $total_issues issues found"
          fi

      - name: Yocto Project Compatible Layer Validation
        run: |
          echo "üèÖ Running official Yocto Project layer compatibility validation..."
          echo "üìã Using yocto-check-layer script from OpenEmbedded-Core"
          
          # Download and run yocto-check-layer script in KAS container environment
          # This validates our layer against official Yocto Project compatibility criteria
          kas-container \
            --runtime-args "-e KAS_MACHINE=imx8mm-jaguar-sentai" \
            shell kas/lmp-dynamicdevices-base.yml -c '
              echo "üîç Checking if yocto-check-layer is available..."
              
              # Find yocto-check-layer script
              if command -v yocto-check-layer >/dev/null 2>&1; then
                echo "‚úÖ Found yocto-check-layer command"
                YOCTO_CHECK_CMD="yocto-check-layer"
              elif [ -f "openembedded-core/scripts/yocto-check-layer" ]; then
                echo "‚úÖ Found yocto-check-layer script in OE-Core"
                YOCTO_CHECK_CMD="openembedded-core/scripts/yocto-check-layer"
              else
                echo "‚ö†Ô∏è  yocto-check-layer not found, searching in build environment..."
                find . -name "yocto-check-layer" -type f 2>/dev/null | head -1
                YOCTO_CHECK_CMD=$(find . -name "yocto-check-layer" -type f 2>/dev/null | head -1)
              fi
              
              if [ -n "$YOCTO_CHECK_CMD" ] && [ -f "$YOCTO_CHECK_CMD" ]; then
                echo "üèÖ Running Yocto Project Compatible layer validation..."
                echo "üìÇ Validating layer: meta-dynamicdevices"
                
                # Run yocto-check-layer on our meta layer
                cd /repo
                python3 "$YOCTO_CHECK_CMD" \
                  --layer-path . \
                  --output-log yocto-layer-check.log \
                  --machine imx8mm-jaguar-sentai \
                  --additional-layers openembedded-core/meta \
                  || echo "‚ö†Ô∏è  Some compatibility issues found - see log for details"
                
                echo ""
                echo "üìä Yocto Project Compatibility Results:"
                if [ -f yocto-layer-check.log ]; then
                  echo "üìã Full validation log:"
                  cat yocto-layer-check.log
                else
                  echo "‚ö†Ô∏è  No log file generated"
                fi
                
              else
                echo "‚ùå yocto-check-layer script not found in build environment"
                echo "üìù Manual validation recommended using:"
                echo "   yocto-check-layer --layer-path . --machine <MACHINE>"
                echo ""
                echo "üîó For manual validation, see:"
                echo "   https://docs.yoctoproject.org/test-manual/yocto-project-compatible.html"
              fi
            '
          
          echo ""
          echo "üìã Yocto Project Compatible Layer Validation Summary:"
          echo "   This validation checks our layer against official Yocto Project"
          echo "   compatibility criteria to ensure it works well with other layers."
          echo ""
          echo "üèÖ Benefits of Yocto Project Compatible certification:"
          echo "   ‚Ä¢ Better interoperability with other layers"
          echo "   ‚Ä¢ Follows established best practices"
          echo "   ‚Ä¢ Easier integration for end users"
          echo "   ‚Ä¢ Reduced conflicts in multi-layer builds"

      - name: Validate device tree syntax
        run: |
          echo "üîç Validating device tree files..."
          
          # Initialize counters
          dt_files=0
          dt_issues=0
          
          # Check .dts files for common issues
          while IFS= read -r -d '' dtfile; do
            dt_files=$((dt_files + 1))
            echo "üìã Checking device tree: $dtfile"
            
            # Check for proper node naming
            if grep -n "[^a-zA-Z0-9_-]@[^0-9a-fA-F]" "$dtfile" >/dev/null 2>&1; then
              echo "  ‚ö†Ô∏è  Invalid node naming detected"
              grep -n "[^a-zA-Z0-9_-]@[^0-9a-fA-F]" "$dtfile" | head -2 | sed 's/^/    /' || true
              dt_issues=$((dt_issues + 1))
            fi
            
            # Check for missing semicolons
            if grep -n "^\s*[a-zA-Z_-].*=" "$dtfile" | grep -v ";" >/dev/null 2>&1; then
              semicolon_count=$(grep -c "^\s*[a-zA-Z_-].*=" "$dtfile" | grep -v ";" || echo "0")
              echo "  ‚ö†Ô∏è  Potential missing semicolons ($semicolon_count lines)"
              grep -n "^\s*[a-zA-Z_-].*=" "$dtfile" | grep -v ";" | head -3 | sed 's/^/    /' || true
              dt_issues=$((dt_issues + 1))
            fi
            
            # Check for proper indentation consistency
            if grep -P "^\t" "$dtfile" >/dev/null 2>&1 && grep "^    " "$dtfile" >/dev/null 2>&1; then
              echo "  ‚ö†Ô∏è  Mixed tabs and spaces indentation detected"
              dt_issues=$((dt_issues + 1))
            fi
            
          done < <(find . -name "*.dts" -o -name "*.dtsi" -print0 2>/dev/null)
          
          echo ""
          echo "üìä Device tree validation summary:"
          echo "  Device tree files checked: $dt_files"
          echo "  Issues found: $dt_issues"
          
          if [ $dt_issues -eq 0 ]; then
            echo "‚úÖ Device tree validation complete - no issues found"
          else
            echo "‚ö†Ô∏è  Device tree validation complete - $dt_issues issues found"
          fi

      - name: CVE and security scanning
        run: |
          echo "üîí Running CVE and security vulnerability scanning..."
          
          # Check for known vulnerable packages in recipes
          echo "Scanning for known vulnerable package versions..."
          
          # Common vulnerable packages to check
          vulnerable_packages=(
            "openssl"
            "glibc" 
            "busybox"
            "dropbear"
            "openssh"
            "curl"
            "wget"
            "zlib"
            "libpng"
            "libjpeg"
            "expat"
            "libxml2"
            "pcre"
            "sqlite3"
            "python3"
            "nodejs"
            "nginx"
            "apache2"
            "bind"
            "dnsmasq"
            "hostapd"
            "wpa-supplicant"
            "bluez5"
            "avahi"
            "systemd"
            "udev"
            "kernel"
            "u-boot"
          )
          
          # Check for hardcoded versions that might be vulnerable
          for pkg in "${vulnerable_packages[@]}"; do
            # Look for version pinning in recipes
            if find recipes* bbappends* conf/ -name "*.bb" -o -name "*.bbappend" -o -name "*.inc" | xargs grep -l "$pkg" 2>/dev/null; then
              echo "üìã Found references to security-sensitive package: $pkg"
              
              # Check for version specifications
              find recipes* bbappends* conf/ -name "*.bb" -o -name "*.bbappend" -o -name "*.inc" | xargs grep -n "PV.*=" 2>/dev/null | grep -i "$pkg" || true
              find recipes* bbappends* conf/ -name "*.bb" -o -name "*.bbappend" -o -name "*.inc" | xargs grep -n "SRCREV.*=" 2>/dev/null | grep -i "$pkg" || true
            fi
          done
          
          # Check for insecure configurations
          echo "Checking for insecure configurations..."
          
          # Check for disabled security features
          security_flags=(
            "INSANE_SKIP.*already-stripped"
            "INSANE_SKIP.*buildpaths"
            "INSANE_SKIP.*textrel"
            "INSANE_SKIP.*ldflags"
            "INSANE_SKIP.*compile-host-path"
            "SECURITY_CFLAGS.*="
            "SECURITY_LDFLAGS.*="
            "FORTIFY_SOURCE.*0"
            "_FORTIFY_SOURCE.*0"
          )
          
          for flag in "${security_flags[@]}"; do
            if find recipes* bbappends* conf/ -name "*.bb" -o -name "*.bbappend" -o -name "*.conf" | xargs grep -n "$flag" 2>/dev/null; then
              echo "‚ö†Ô∏è  Found potentially insecure configuration: $flag"
            fi
          done
          
          # Check for hardcoded secrets or credentials
          echo "Scanning for hardcoded secrets..."
          
          secret_patterns=(
            "password.*="
            "passwd.*="
            "secret.*="
            "key.*="
            "token.*="
            "api_key"
            "private_key"
            "ssh_key"
            "rsa_key"
            "certificate"
          )
          
          for pattern in "${secret_patterns[@]}"; do
            if find recipes* bbappends* conf/ -name "*.bb" -o -name "*.bbappend" -o -name "*.conf" | xargs grep -in "$pattern" 2>/dev/null | grep -v "DESCRIPTION\|SUMMARY\|HOMEPAGE" | head -5; then
              echo "‚ö†Ô∏è  Potential hardcoded secret found matching: $pattern"
            fi
          done
          
          # Check for insecure network configurations
          echo "Checking for insecure network configurations..."
          
          insecure_network=(
            "http://.*download"
            "ftp://.*download"
            "DISABLE_STATIC.*0"
            "ALLOW_EMPTY.*1"
            "INSANE_SKIP.*host-user-contaminated"
          )
          
          for pattern in "${insecure_network[@]}"; do
            if find recipes* bbappends* conf/ -name "*.bb" -o -name "*.bbappend" -o -name "*.conf" | xargs grep -n "$pattern" 2>/dev/null; then
              echo "‚ö†Ô∏è  Insecure network configuration found: $pattern"
            fi
          done
          
          # Check for proper license compliance (security through legal compliance)
          echo "Checking license compliance..."
          
          if find recipes* bbappends* -name "*.bb" -o -name "*.bbappend" | xargs grep -L "LICENSE.*=" 2>/dev/null | head -5; then
            echo "‚ö†Ô∏è  Recipes missing LICENSE declaration found"
          fi
          
          # Check for CLOSED license (potential proprietary/security issues)
          if find recipes* bbappends* -name "*.bb" -o -name "*.bbappend" | xargs grep -n "LICENSE.*CLOSED" 2>/dev/null; then
            echo "‚ö†Ô∏è  Found recipes with CLOSED license - review for security implications"
          fi
          
          echo "‚úÖ CVE and security scanning complete"

      - name: Check for security-related TODOs and FIXMEs
        run: |
          echo "üîç Scanning for security-related TODOs and issues..."
          
          security_keywords=(
            "TODO.*security"
            "FIXME.*security"
            "TODO.*cve"
            "FIXME.*cve"
            "TODO.*vuln"
            "FIXME.*vuln"
            "TODO.*exploit"
            "FIXME.*exploit"
            "HACK.*security"
            "XXX.*security"
          )
          
          found_issues=0
          for keyword in "${security_keywords[@]}"; do
            if find . -name "*.bb" -o -name "*.bbappend" -o -name "*.conf" -o -name "*.sh" -o -name "*.py" | xargs grep -in "$keyword" 2>/dev/null; then
              echo "‚ö†Ô∏è  Security-related TODO/FIXME found: $keyword"
              found_issues=$((found_issues + 1))
            fi
          done
          
          if [ $found_issues -gt 0 ]; then
            echo "‚ö†Ô∏è  Found $found_issues security-related TODOs/FIXMEs that should be addressed"
          else
            echo "‚úÖ No security-related TODOs/FIXMEs found"
          fi

      - name: Validate build reproducibility and development settings
        run: |
          echo "üîÑ Checking build reproducibility and development build settings..."
          echo "üìù NOTE: These are DEBUG/DEVELOPMENT builds for CI validation - not production builds"
          
          # Check for SOURCE_DATE_EPOCH usage
          if ! find conf/ -name "*.conf" | xargs grep -q "SOURCE_DATE_EPOCH" 2>/dev/null; then
            echo "‚ö†Ô∏è  SOURCE_DATE_EPOCH not configured - builds may not be reproducible"
          else
            echo "‚úÖ SOURCE_DATE_EPOCH configured for reproducible builds"
          fi
          
          # Check for proper DISTRO security features
          security_features=(
            "DISTRO_FEATURES.*pam"
            "DISTRO_FEATURES.*systemd"
            "DISTRO_FEATURES.*selinux"
            "DISTRO_FEATURES.*smack"
            "DISTRO_FEATURES.*ima"
          )
          
          echo ""
          echo "üîí Checking security-related DISTRO_FEATURES..."
          for feature in "${security_features[@]}"; do
            if find conf/ -name "*.conf" | xargs grep -q "$feature" 2>/dev/null; then
              echo "‚úÖ Found security feature: $feature"
            fi
          done
          
          # Check for development/debug IMAGE_FEATURES (expected in CI builds)
          echo ""
          echo "üõ†Ô∏è  Checking development features (expected in CI/debug builds):"
          
          if find conf/ recipes* -name "*.bb" -o -name "*.conf" | xargs grep -q "IMAGE_FEATURES.*ssh-server-openssh" 2>/dev/null; then
            echo "‚úÖ OpenSSH server enabled (normal for development builds)"
            echo "   üìù Production builds should use secure key management"
          fi
          
          if find conf/ recipes* -name "*.bb" -o -name "*.conf" | xargs grep -q "IMAGE_FEATURES.*debug-tweaks" 2>/dev/null; then
            echo "‚úÖ debug-tweaks enabled (normal for CI/development builds)"
            echo "   üìù Production builds should disable debug-tweaks"
          fi
          
          # Check for other development features
          dev_features=(
            "IMAGE_FEATURES.*package-management"
            "IMAGE_FEATURES.*dev-pkgs"
            "IMAGE_FEATURES.*dbg-pkgs"
            "IMAGE_FEATURES.*tools-debug"
          )
          
          for feature in "${dev_features[@]}"; do
            if find conf/ recipes* -name "*.bb" -o -name "*.conf" | xargs grep -q "$feature" 2>/dev/null; then
              echo "‚úÖ Development feature found: $(echo $feature | sed 's/.*\*//')"
            fi
          done
          
          echo ""
          echo "‚úÖ Build configuration validation complete"
          echo "üè≠ Build Type: DEVELOPMENT/CI (includes debug features)"

      - name: Generate SBOM for recipes
        run: |
          echo "üìã Generating Software Bill of Materials (SBOM) for validation..."
          
          # Create SBOM directory
          mkdir -p sbom-validation
          
          # Generate recipe inventory
          echo "Collecting recipe inventory..."
          cat > sbom-validation/recipe-inventory.json << 'EOF'
          {
            "sbom_version": "1.0",
            "generated_date": "$(date -Iseconds)",
            "generator": "Dynamic Devices CI Pipeline",
            "project": "meta-dynamicdevices",
            "commit": "${{ github.sha }}",
            "recipes": [
          EOF
          
          # Parse all recipes and create inventory
          first_recipe=true
          find recipes* bbappends* -name "*.bb" -o -name "*.bbappend" | while read -r recipe; do
            # Extract basic recipe information
            recipe_name=$(basename "$recipe" | sed 's/_.*\.bb.*//')
            recipe_path="$recipe"
            
            # Extract version if available
            version=$(grep "^PV.*=" "$recipe" 2>/dev/null | cut -d'"' -f2 || echo "unknown")
            if [ "$version" = "unknown" ]; then
              version=$(grep "^PV.*=" "$recipe" 2>/dev/null | cut -d"'" -f2 || echo "unknown")
            fi
            
            # Extract license
            license=$(grep "^LICENSE.*=" "$recipe" 2>/dev/null | cut -d'"' -f2 || echo "unknown")
            if [ "$license" = "unknown" ]; then
              license=$(grep "^LICENSE.*=" "$recipe" 2>/dev/null | cut -d"'" -f2 || echo "unknown")
            fi
            
            # Extract source URI
            src_uri=$(grep "^SRC_URI.*=" "$recipe" 2>/dev/null | head -1 || echo "")
            
            # Extract dependencies
            depends=$(grep "^DEPENDS.*=" "$recipe" 2>/dev/null | cut -d'"' -f2 || echo "")
            rdepends=$(grep "^RDEPENDS.*=" "$recipe" 2>/dev/null | cut -d'"' -f2 || echo "")
            
            # Add comma if not first recipe
            if [ "$first_recipe" = false ]; then
              echo "," >> sbom-validation/recipe-inventory.json
            fi
            first_recipe=false
            
            # Add recipe entry
            cat >> sbom-validation/recipe-inventory.json << EOF
              {
                "name": "$recipe_name",
                "version": "$version",
                "license": "$license",
                "path": "$recipe_path",
                "src_uri": "$src_uri",
                "build_depends": "$depends",
                "runtime_depends": "$rdepends",
                "recipe_type": "$(if [[ $recipe == *.bbappend ]]; then echo 'bbappend'; else echo 'bb'; fi)"
              }
          EOF
          done
          
          # Close JSON
          cat >> sbom-validation/recipe-inventory.json << 'EOF'
            ]
          }
          EOF
          
          echo "‚úÖ Recipe SBOM inventory generated"
          echo "üìä Recipe count: $(find recipes* bbappends* -name "*.bb" -o -name "*.bbappend" | wc -l)"

  # Main build job with matrix strategy
  build:
    runs-on: self-hosted
    needs: [setup, validate]
    if: needs.setup.outputs.should_build == 'true'
    strategy:
      fail-fast: false
      matrix:
        machine: ${{ fromJSON(needs.setup.outputs.machines) }}
        build_type: [base, mfgtool]
        # Build mfgtool for all machines - needed for board programming
    
    env:
      KAS_MACHINE: ${{ matrix.machine }}
      BUILD_TYPE: ${{ matrix.build_type }}
    
    steps:
      - name: Clean up workspace for self-hosted runner
        run: |
          echo "üßπ Cleaning up workspace for self-hosted runner"
          # Clean up any previous build artifacts to free space
          if [ -d "${{ github.workspace }}" ]; then
            cd "${{ github.workspace }}"
            # Remove any large build directories from previous runs
            rm -rf build tmp-glibc deploy artifacts programming-packages || true
            # Clean docker containers and images if any
            docker system prune -f || true
          fi

      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Setup Docker environment for Yocto builds
        run: |
          echo "üê≥ Setting up Docker environment for Yocto builds"
          
          # Verify Docker is available on self-hosted runner
          if ! command -v docker >/dev/null 2>&1; then
            echo "‚ùå Docker not available on self-hosted runner"
            exit 1
          fi
          
          echo "‚úÖ Docker is available"
          docker --version
          
          # Download kas-container script (minimal host dependency)
          if ! command -v kas-container >/dev/null 2>&1; then
            echo "üì• Downloading kas-container script..."
            wget -O kas-container https://raw.githubusercontent.com/siemens/kas/master/kas-container
            chmod +x kas-container
            # Add to PATH for this workflow
            echo "$PWD" >> $GITHUB_PATH
          else
            echo "‚úÖ kas-container already available"
          fi
          
          # Test kas-container works with Docker
          echo "üß™ Testing kas-container with Docker..."
          ./kas-container --help > /dev/null
          echo "‚úÖ kas-container is ready"

      - name: Setup persistent cache for Docker builds
        run: |
          echo "üóÑÔ∏è Setting up persistent build cache for Docker-based Yocto builds"
          
          # Use a persistent cache directory on the self-hosted runner
          # This will be mounted into the Docker container by kas-container
          CACHE_BASE="$HOME/yocto-cache"
          BUILD_DIR="$HOME/yocto-builds"
          
          # Create persistent cache and build directories
          mkdir -p "$CACHE_BASE"/{downloads,sstate}
          mkdir -p "$BUILD_DIR"
          
          echo "üìä Cache directory sizes:"
          du -sh "$CACHE_BASE"/* 2>/dev/null || echo "Cache directories are empty (first run)"
          
          echo "üèóÔ∏è Build directory:"
          ls -la "$BUILD_DIR" 2>/dev/null || echo "Build directory is empty (first run)"
          
          # Export paths for kas-container to use
          echo "KAS_WORK_DIR=$BUILD_DIR" >> $GITHUB_ENV
          echo "DL_DIR=$CACHE_BASE/downloads" >> $GITHUB_ENV
          echo "SSTATE_DIR=$CACHE_BASE/sstate" >> $GITHUB_ENV
          
          echo "‚úÖ Docker build environment configured:"
          echo "   Work dir: $BUILD_DIR"
          echo "   Downloads: $CACHE_BASE/downloads"
          echo "   SSstate: $CACHE_BASE/sstate"

      - name: Set up build environment for self-hosted runner
        run: |
          echo "üöÄ Setting up build environment for ${{ matrix.machine }} (${{ matrix.build_type }})"
          
          # Create yocto cache directories (persistent symlinks already created)
          mkdir -p ~/yocto/persistent
          chmod 755 ~/yocto/persistent
          
          # Detect available CPU cores for optimal parallel builds
          NPROC=$(nproc)
          # Use 75% of available cores to leave some for system
          BUILD_THREADS=$((NPROC * 3 / 4))
          BUILD_THREADS=${BUILD_THREADS:-4}  # Minimum 4 threads
          
          echo "üñ•Ô∏è Self-hosted runner specs:"
          echo "  CPU cores: $NPROC"
          echo "  Build threads: $BUILD_THREADS"
          echo "  RAM: $(free -h | awk '/^Mem:/ {print $2}')"
          echo "  Disk space: $(df -h . | awk 'NR==2 {print $4}')"
          
          # Set optimized environment variables for self-hosted runner
          echo "BB_NUMBER_THREADS=$BUILD_THREADS" >> $GITHUB_ENV
          echo "PARALLEL_MAKE=-j$BUILD_THREADS" >> $GITHUB_ENV
          
          # Disable interactive features
          echo "DEBIAN_FRONTEND=noninteractive" >> $GITHUB_ENV
          
          # For development builds, disable signing to avoid key issues
          echo "OPTEE_TA_SIGN_ENABLE=0" >> $GITHUB_ENV
          echo "SIGN_ENABLE=0" >> $GITHUB_ENV
          echo "UBOOT_SIGN_ENABLE=0" >> $GITHUB_ENV
          echo "UBOOT_SPL_SIGN_ENABLE=0" >> $GITHUB_ENV
          echo "TF_A_SIGN_ENABLE=0" >> $GITHUB_ENV
          echo "UEFI_SIGN_ENABLE=0" >> $GITHUB_ENV

      - name: Build with KAS
        timeout-minutes: 240  # 4 hour timeout
        run: |
          echo "üî® Starting KAS build: ${{ matrix.machine }} (${{ matrix.build_type }})"
          
          # Select appropriate KAS configuration
          if [ "${{ matrix.build_type }}" = "mfgtool" ]; then
            kas_config="kas/lmp-dynamicdevices-mfgtool.yml"
          else
            kas_config="kas/lmp-dynamicdevices-base.yml"
          fi
          
          echo "Using KAS config: $kas_config"
          echo "Machine: $KAS_MACHINE"
          
          # Run KAS build in Docker container (all tools and dependencies included)
          kas-container \
            --runtime-args "-e KAS_MACHINE=$KAS_MACHINE \
                           -e DL_DIR=$DL_DIR \
                           -e SSTATE_DIR=$SSTATE_DIR \
                           -e BB_NUMBER_THREADS=$BB_NUMBER_THREADS \
                           -e PARALLEL_MAKE='$PARALLEL_MAKE' \
                           -e OPTEE_TA_SIGN_ENABLE=$OPTEE_TA_SIGN_ENABLE \
                           -e SIGN_ENABLE=$SIGN_ENABLE \
                           -e UBOOT_SIGN_ENABLE=$UBOOT_SIGN_ENABLE \
                           -e UBOOT_SPL_SIGN_ENABLE=$UBOOT_SPL_SIGN_ENABLE \
                           -e TF_A_SIGN_ENABLE=$TF_A_SIGN_ENABLE \
                           -e UEFI_SIGN_ENABLE=$UEFI_SIGN_ENABLE" \
            build "$kas_config"

      - name: Collect BitBake-generated SBOM
        if: always()
        run: |
          echo "üìã Collecting BitBake-generated Software Bill of Materials..."
          
          # Create SBOM directory
          mkdir -p build-sbom/${{ matrix.machine }}/${{ matrix.build_type }}
          
          # BitBake with create-spdx generates comprehensive SPDX files
          deploy_dir="$KAS_WORK_DIR/build/tmp/deploy/images/${{ matrix.machine }}"
          spdx_dir="$KAS_WORK_DIR/build/tmp/deploy/spdx/${{ matrix.machine }}"
          
          if [ -d "$spdx_dir" ]; then
            echo "‚úÖ Found BitBake-generated SPDX/SBOM files"
            
            # Copy all SPDX files (these are the comprehensive SBOMs)
            if [ -f "$spdx_dir/lmp-factory-image-${{ matrix.machine }}.spdx.json" ]; then
              cp "$spdx_dir/lmp-factory-image-${{ matrix.machine }}.spdx.json" \
                 "build-sbom/${{ matrix.machine }}/${{ matrix.build_type }}/image-sbom.spdx.json"
              echo "üì¶ Copied image SPDX SBOM"
            fi
            
            # Copy individual package SBOMs if available
            find "$spdx_dir" -name "*.spdx.json" -exec cp {} "build-sbom/${{ matrix.machine }}/${{ matrix.build_type }}/" \;
            
            # Create summary of SBOM files
            echo "## BitBake-Generated SBOM Files" > build-sbom/${{ matrix.machine }}/${{ matrix.build_type }}/README.md
            echo "" >> build-sbom/${{ matrix.machine }}/${{ matrix.build_type }}/README.md
            echo "**Machine**: ${{ matrix.machine }}" >> build-sbom/${{ matrix.machine }}/${{ matrix.build_type }}/README.md
            echo "**Build Type**: ${{ matrix.build_type }}" >> build-sbom/${{ matrix.machine }}/${{ matrix.build_type }}/README.md
            echo "**Generated**: $(date -Iseconds)" >> build-sbom/${{ matrix.machine }}/${{ matrix.build_type }}/README.md
            echo "**Commit**: ${{ github.sha }}" >> build-sbom/${{ matrix.machine }}/${{ matrix.build_type }}/README.md
            echo "" >> build-sbom/${{ matrix.machine }}/${{ matrix.build_type }}/README.md
            echo "### SPDX 2.3 Compliant Files:" >> build-sbom/${{ matrix.machine }}/${{ matrix.build_type }}/README.md
            
            cd build-sbom/${{ matrix.machine }}/${{ matrix.build_type }}
            for file in *.spdx.json; do
              if [ -f "$file" ]; then
                size=$(du -h "$file" | cut -f1)
                echo "- \`$file\` ($size)" >> README.md
              fi
            done
            cd ../../../
            
            echo "‚úÖ BitBake SBOM collection complete for ${{ matrix.machine }} (${{ matrix.build_type }})"
          else
            echo "‚ö†Ô∏è  No BitBake SPDX files found - SBOM generation may have failed"
            echo "Expected location: $spdx_dir"
            
            # Fallback: create basic manifest-based SBOM if image manifest exists
            if [ -f "$deploy_dir/lmp-factory-image-${{ matrix.machine }}.manifest" ]; then
              echo "üì¶ Creating basic SBOM from image manifest as fallback"
              cp "$deploy_dir/lmp-factory-image-${{ matrix.machine }}.manifest" \
                 "build-sbom/${{ matrix.machine }}/${{ matrix.build_type }}/package-manifest.txt"
            fi
          fi

      - name: Collect build artifacts
        if: always()
        run: |
          echo "üì¶ Collecting build artifacts for ${{ matrix.machine }} (${{ matrix.build_type }})"
          
          # Create artifacts directories
          mkdir -p artifacts/${{ matrix.machine }}/${{ matrix.build_type }}
          mkdir -p programming-packages/${{ matrix.machine }}
          
          # Define deploy directory (inside the kas work directory)
          deploy_dir="$KAS_WORK_DIR/build/tmp/deploy/images/${{ matrix.machine }}"
          
          if [ -d "$deploy_dir" ]; then
            echo "‚úÖ Deploy directory found: $deploy_dir"
            
            # Copy all build artifacts
            artifacts=(
              "*.wic.gz"
              "*.wic.bmap"
              "imx-boot-*"
              "u-boot-*.itb"
              "*.dtb"
              "*.manifest"
            )
            
            for pattern in "${artifacts[@]}"; do
              if ls "$deploy_dir"/$pattern 1> /dev/null 2>&1; then
                cp "$deploy_dir"/$pattern artifacts/${{ matrix.machine }}/${{ matrix.build_type }}/
                echo "üìÅ Copied to artifacts: $pattern"
              fi
            done
            
            # Create board-specific programming package
            if [ "${{ matrix.build_type }}" = "base" ]; then
              echo "üì¶ Creating programming package for ${{ matrix.machine }}"
              
              # Files needed for UUU programming (from program_full_image.uuu.in)
              programming_files=(
                "lmp-factory-image-${{ matrix.machine }}.wic.gz"
                "imx-boot-${{ matrix.machine }}"
                "u-boot-${{ matrix.machine }}.itb"
              )
              
              # Copy programming files
              for file in "${programming_files[@]}"; do
                if [ -f "$deploy_dir/$file" ]; then
                  cp "$deploy_dir/$file" programming-packages/${{ matrix.machine }}/
                  echo "üìã Added to programming package: $file"
                else
                  echo "‚ö†Ô∏è  Programming file not found: $file"
                fi
              done
              
              # Note: mfgtool files will be added by the mfgtool build job
              echo "üìã Base build complete - mfgtool files will be added by mfgtool build"
            elif [ "${{ matrix.build_type }}" = "mfgtool" ]; then
              echo "üì¶ Adding mfgtool files to programming package for ${{ matrix.machine }}"
              
              # Mfgtool files needed for UUU programming  
              mfgtool_files=(
                "imx-boot-mfgtool"
                "u-boot-mfgtool.itb"
              )
              
              # Add mfgtool files to existing programming package
              for file in "${mfgtool_files[@]}"; do
                if [ -f "$deploy_dir/$file" ]; then
                  cp "$deploy_dir/$file" programming-packages/${{ matrix.machine }}/
                  echo "üìã Added mfgtool file: $file"
                else
                  echo "‚ö†Ô∏è  Mfgtool file not found: $file"
                fi
              done
              
              # Update the programming script to indicate mfgtool files are now available
              if [ -f "programming-packages/${{ matrix.machine }}/program-${{ matrix.machine }}.sh" ]; then
                echo "üìã Mfgtool files added to existing programming package"
              else
                echo "‚ö†Ô∏è  Programming package not found - base build may have failed"
              fi
              
              # Create programming script for this machine
              cat > programming-packages/${{ matrix.machine }}/program-${{ matrix.machine }}.sh << 'EOF'
          #!/bin/bash
          # Board Programming Script for ${{ matrix.machine }}
          # Generated automatically by CI build
          
          set -e
          
          MACHINE="${{ matrix.machine }}"
          SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
          
          echo "üöÄ Programming $MACHINE board..."
          echo "üìÅ Using files from: $SCRIPT_DIR"
          
          # Verify required files exist
          required_files=(
              "imx-boot-mfgtool"
              "u-boot-mfgtool.itb"
              "lmp-factory-image-$MACHINE.wic.gz"
              "imx-boot-$MACHINE"
              "u-boot-$MACHINE.itb"
          )
          
          for file in "${required_files[@]}"; do
              if [ ! -f "$SCRIPT_DIR/$file" ]; then
                  echo "‚ùå Required file missing: $file"
                  exit 1
              fi
          done
          
          # Create UUU script
          cat > "$SCRIPT_DIR/program_$MACHINE.uuu" << UUU_EOF
          uuu_version 1.2.39
          
          SDP: boot -f imx-boot-mfgtool
          
          SDPV: delay 1000
          SDPV: write -f u-boot-mfgtool.itb
          SDPV: jump
          
          FB: ucmd setenv fastboot_dev mmc
          FB: ucmd setenv mmcdev \${emmc_dev}
          FB: ucmd mmc dev \${emmc_dev} 1; mmc erase 0 0x2000
          FB: flash -raw2sparse all lmp-factory-image-$MACHINE.wic.gz/*
          FB: flash bootloader imx-boot-$MACHINE
          FB: flash bootloader2 u-boot-$MACHINE.itb
          FB: flash bootloader_s imx-boot-$MACHINE
          FB: flash bootloader2_s u-boot-$MACHINE.itb
          FB: ucmd if env exists emmc_ack; then ; else setenv emmc_ack 0; fi;
          FB: ucmd mmc partconf \${emmc_dev} \${emmc_ack} 1 0
          FB: done
          UUU_EOF
          
          echo "‚úÖ Created UUU script: program_$MACHINE.uuu"
          echo "üîå Connect board in download mode and run:"
          echo "   sudo uuu program_$MACHINE.uuu"
          
          # Optionally run UUU if requested
          if [ "${1:-}" = "--flash" ]; then
              echo "üöÄ Starting board programming..."
              sudo uuu "program_$MACHINE.uuu"
          fi
          EOF
              
              chmod +x programming-packages/${{ matrix.machine }}/program-${{ matrix.machine }}.sh
              
              # Create README for programming package
              cat > programming-packages/${{ matrix.machine }}/README.md << 'EOF'
          # Programming Package for ${{ matrix.machine }}
          
          **Generated**: $(date)  
          **Commit**: ${{ github.sha }}  
          **Branch**: ${{ github.ref_name }}
          
          ## Files Included
          
          ### Bootloaders
          - `imx-boot-mfgtool` - Manufacturing tool bootloader
          - `u-boot-mfgtool.itb` - Manufacturing tool U-Boot
          - `imx-boot-${{ matrix.machine }}` - Production bootloader  
          - `u-boot-${{ matrix.machine }}.itb` - Production U-Boot
          
          ### System Image
          - `lmp-factory-image-${{ matrix.machine }}.wic.gz` - Complete system image
          
          ### Programming Tools
          - `program-${{ matrix.machine }}.sh` - Automated programming script
          - `program_${{ matrix.machine }}.uuu` - UUU programming script (auto-generated)
          
          ### Software Bill of Materials (SBOM)
          - `sbom/` - BitBake-generated SPDX 2.3 compliant SBOM files
          - `sbom/image-sbom.spdx.json` - Complete image SBOM (if available)
          - `sbom/*.spdx.json` - Individual package SBOMs
          - `sbom/package-manifest.txt` - Package manifest (fallback)
          
          ## Usage
          
          ### Prerequisites
          - Install NXP UUU tool
          - Connect ${{ matrix.machine }} board via USB in download mode
          
          ### Programming Steps
          
          1. **Put board in download mode**
          2. **Connect USB cable**
          3. **Run programming script**:
             ```bash
             ./program-${{ matrix.machine }}.sh --flash
             ```
          
          ### Manual Programming
          
          If you prefer manual control:
          ```bash
          sudo uuu program_${{ matrix.machine }}.uuu
          ```
          
          ## Board-Specific Notes
          
          - **Machine**: ${{ matrix.machine }}
          - **Architecture**: $(echo "${{ matrix.machine }}" | grep -q "imx8mm" && echo "i.MX8M Mini" || echo "i.MX93")
          - **Board Type**: $(echo "${{ matrix.machine }}" | sed 's/.*jaguar-//' | tr '[:lower:]' '[:upper:]')
          
          EOF
            fi
            
            # Create build artifact summary
            echo "# Build Artifacts for ${{ matrix.machine }} (${{ matrix.build_type }})" > artifacts/${{ matrix.machine }}/${{ matrix.build_type }}/README.md
            echo "Generated on: $(date)" >> artifacts/${{ matrix.machine }}/${{ matrix.build_type }}/README.md
            echo "Commit: ${{ github.sha }}" >> artifacts/${{ matrix.machine }}/${{ matrix.build_type }}/README.md
            echo "" >> artifacts/${{ matrix.machine }}/${{ matrix.build_type }}/README.md
            echo "## Files:" >> artifacts/${{ matrix.machine }}/${{ matrix.build_type }}/README.md
            
            cd artifacts/${{ matrix.machine }}/${{ matrix.build_type }}
            for file in *; do
              if [ "$file" != "README.md" ]; then
                size=$(du -h "$file" | cut -f1)
                echo "- $file ($size)" >> README.md
              fi
            done
            cd ../../../
            
          else
            echo "‚ùå Deploy directory not found: $deploy_dir"
            echo "Available directories in kas work dir:"
            ls -la "$KAS_WORK_DIR/build/tmp/deploy/" 2>/dev/null || echo "No deploy directory found"
            echo "Available directories in kas work dir build:"
            ls -la "$KAS_WORK_DIR/build/" 2>/dev/null || echo "No build directory found"
          fi

      - name: Upload build artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: build-artifacts-${{ matrix.machine }}-${{ matrix.build_type }}
          path: artifacts/
          retention-days: 30
          if-no-files-found: warn

      - name: Upload SBOM artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: sbom-${{ matrix.machine }}-${{ matrix.build_type }}
          path: build-sbom/
          retention-days: 90
          if-no-files-found: warn

      - name: Upload programming packages
        if: always() && matrix.build_type == 'base'
        uses: actions/upload-artifact@v4
        with:
          name: programming-package-${{ matrix.machine }}
          path: programming-packages/${{ matrix.machine }}/
          retention-days: 90
          if-no-files-found: warn

      - name: Generate build report
        if: always()
        run: |
          echo "üìä Generating build report"
          
          # Create build report
          cat > build-report-${{ matrix.machine }}-${{ matrix.build_type }}.md << EOF
          # Build Report: ${{ matrix.machine }} (${{ matrix.build_type }})
          
          **üõ†Ô∏è BUILD TYPE: DEVELOPMENT/DEBUG BUILD FOR CI VALIDATION**
          
          **Date:** $(date)
          **Commit:** ${{ github.sha }}
          **Branch:** ${{ github.ref_name }}
          **Workflow:** ${{ github.workflow }}
          **Run:** ${{ github.run_number }}
          
          ## Build Configuration
          - **Machine:** ${{ matrix.machine }}
          - **Build Type:** ${{ matrix.build_type }}
          - **KAS Configuration:** $([ "${{ matrix.build_type }}" = "mfgtool" ] && echo "kas/lmp-dynamicdevices-mfgtool.yml" || echo "kas/lmp-dynamicdevices-base.yml")
          - **Purpose:** CI Validation, Testing, Development
          
          ## Build Status
          - **Status:** ${{ job.status }}
          - **Duration:** \$(expr \$SECONDS / 60) minutes
          
          ## Build Environment
          - **Runner:** self-hosted (Yocto Docker container)
          - **Parallel Jobs:** \$BB_NUMBER_THREADS
          - **Make Jobs:** \$PARALLEL_MAKE
          
          ## Development Build Features
          - **Debug Features:** Enabled (debug-tweaks, package management)
          - **SSH Access:** Enabled for development/debugging
          - **Signing:** Disabled (development build)
          - **Package Management:** Enabled for runtime updates
          
          ## Production Build Notes
          - **‚ö†Ô∏è NOT FOR PRODUCTION:** This is a debug/development build
          - **Production builds should:** Disable debug-tweaks, enable signing, restrict SSH access
          - **Security:** Development builds include debugging tools and relaxed security
          
          EOF
          
          # Check if artifacts were created
          if [ -d "artifacts/${{ matrix.machine }}/${{ matrix.build_type }}" ]; then
            echo "## Artifacts Generated" >> build-report-${{ matrix.machine }}-${{ matrix.build_type }}.md
            echo "‚úÖ Build artifacts available for download" >> build-report-${{ matrix.machine }}-${{ matrix.build_type }}.md
          else
            echo "## Artifacts" >> build-report-${{ matrix.machine }}-${{ matrix.build_type }}.md
            echo "‚ùå No artifacts generated" >> build-report-${{ matrix.machine }}-${{ matrix.build_type }}.md
          fi

      - name: Upload build report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: build-report-${{ matrix.machine }}-${{ matrix.build_type }}
          path: build-report-${{ matrix.machine }}-${{ matrix.build_type }}.md
          retention-days: 90

  # Create final programming packages combining base + mfgtool artifacts
  create-programming-packages:
    runs-on: self-hosted
    needs: [setup, build]
    # Only create programming packages if the build job succeeded
    if: needs.setup.outputs.should_build == 'true' && needs.build.result == 'success'
    strategy:
      matrix:
        machine: ${{ fromJSON(needs.setup.outputs.machines) }}
    steps:
      - name: Download base build artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-artifacts-${{ matrix.machine }}-base
          path: base-artifacts/
        continue-on-error: false  # Fail if base artifacts missing

      - name: Download mfgtool build artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-artifacts-${{ matrix.machine }}-mfgtool
          path: mfgtool-artifacts/
        continue-on-error: false  # Fail if mfgtool artifacts missing

      - name: Create complete programming package
        run: |
          echo "üì¶ Creating complete programming package for ${{ matrix.machine }}"
          
          # Verify both base and mfgtool artifacts are available
          if [ ! -d "base-artifacts/${{ matrix.machine }}/base" ]; then
            echo "‚ùå Base build artifacts missing for ${{ matrix.machine }}"
            exit 1
          fi
          
          if [ ! -d "mfgtool-artifacts/${{ matrix.machine }}/mfgtool" ]; then
            echo "‚ùå Mfgtool build artifacts missing for ${{ matrix.machine }}"
            exit 1
          fi
          
          echo "‚úÖ Both base and mfgtool artifacts found for ${{ matrix.machine }}"
          
          # Create programming package directory
          mkdir -p programming-packages/${{ matrix.machine }}
          
          # Copy base build files (already verified to exist)
          echo "üìã Adding base build files..."
          
          # Files needed for UUU programming
          base_files=(
            "lmp-factory-image-${{ matrix.machine }}.wic.gz"
            "imx-boot-${{ matrix.machine }}"
            "u-boot-${{ matrix.machine }}.itb"
          )
          
          missing_base_files=()
          for file in "${base_files[@]}"; do
            if [ -f "base-artifacts/${{ matrix.machine }}/base/$file" ]; then
              cp "base-artifacts/${{ matrix.machine }}/base/$file" "programming-packages/${{ matrix.machine }}/"
              echo "‚úÖ Added: $file"
            else
              missing_base_files+=("$file")
            fi
          done
          
          if [ ${#missing_base_files[@]} -gt 0 ]; then
            echo "‚ùå Missing base files:"
            printf '  - %s\n' "${missing_base_files[@]}"
            exit 1
          fi
          
          # Copy mfgtool files (already verified to exist)
          echo "üìã Adding mfgtool files..."
          
          # Mfgtool files
          mfgtool_files=(
            "imx-boot-mfgtool"
            "u-boot-mfgtool.itb"
          )
          
          missing_mfgtool_files=()
          for file in "${mfgtool_files[@]}"; do
            if [ -f "mfgtool-artifacts/${{ matrix.machine }}/mfgtool/$file" ]; then
              cp "mfgtool-artifacts/${{ matrix.machine }}/mfgtool/$file" "programming-packages/${{ matrix.machine }}/"
              echo "‚úÖ Added: $file"
            else
              missing_mfgtool_files+=("$file")
            fi
          done
          
          if [ ${#missing_mfgtool_files[@]} -gt 0 ]; then
            echo "‚ùå Missing mfgtool files:"
            printf '  - %s\n' "${missing_mfgtool_files[@]}"
            exit 1
          fi
          
          # Copy BitBake-generated SBOM files to programming package
          echo "üìã Adding BitBake-generated SBOM files to programming package..."
          
          # Create SBOM directory in programming package
          mkdir -p "programming-packages/${{ matrix.machine }}/sbom"
          
          # Copy base build SPDX SBOM files if available
          if [ -d "build-sbom/${{ matrix.machine }}/base" ]; then
            if ls build-sbom/${{ matrix.machine }}/base/*.spdx.json 1> /dev/null 2>&1; then
              cp build-sbom/${{ matrix.machine }}/base/*.spdx.json "programming-packages/${{ matrix.machine }}/sbom/" 2>/dev/null || true
              echo "‚úÖ Added base build SPDX SBOM files"
            fi
            if ls build-sbom/${{ matrix.machine }}/base/*.txt 1> /dev/null 2>&1; then
              cp build-sbom/${{ matrix.machine }}/base/*.txt "programming-packages/${{ matrix.machine }}/sbom/" 2>/dev/null || true
            fi
          fi
          
          # Copy mfgtool build SPDX SBOM files if available  
          if [ -d "build-sbom/${{ matrix.machine }}/mfgtool" ]; then
            if ls build-sbom/${{ matrix.machine }}/mfgtool/*.spdx.json 1> /dev/null 2>&1; then
              cp build-sbom/${{ matrix.machine }}/mfgtool/*.spdx.json "programming-packages/${{ matrix.machine }}/sbom/" 2>/dev/null || true
              echo "‚úÖ Added mfgtool build SPDX SBOM files"
            fi
            if ls build-sbom/${{ matrix.machine }}/mfgtool/*.txt 1> /dev/null 2>&1; then
              cp build-sbom/${{ matrix.machine }}/mfgtool/*.txt "programming-packages/${{ matrix.machine }}/sbom/" 2>/dev/null || true
            fi
          fi
          
          # Create programming script
          cat > programming-packages/${{ matrix.machine }}/program-${{ matrix.machine }}.sh << 'EOF'
          #!/bin/bash
          # Board Programming Script for ${{ matrix.machine }}
          # Generated automatically by CI build
          
          set -e
          
          MACHINE="${{ matrix.machine }}"
          SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
          
          echo "üöÄ Programming $MACHINE board..."
          echo "üìÅ Using files from: $SCRIPT_DIR"
          
          # Verify required files exist
          required_files=(
              "imx-boot-mfgtool"
              "u-boot-mfgtool.itb"
              "lmp-factory-image-$MACHINE.wic.gz"
              "imx-boot-$MACHINE"
              "u-boot-$MACHINE.itb"
          )
          
          missing_files=()
          for file in "${required_files[@]}"; do
              if [ ! -f "$SCRIPT_DIR/$file" ]; then
                  missing_files+=("$file")
              fi
          done
          
          if [ ${#missing_files[@]} -gt 0 ]; then
              echo "‚ùå Missing required files:"
              printf '  - %s\n' "${missing_files[@]}"
              echo ""
              echo "Available files:"
              ls -la "$SCRIPT_DIR"
              exit 1
          fi
          
          echo "‚úÖ All required files present"
          
          # Create UUU script
          cat > "$SCRIPT_DIR/program_$MACHINE.uuu" << UUU_EOF
          uuu_version 1.2.39
          
          SDP: boot -f imx-boot-mfgtool
          
          SDPV: delay 1000
          SDPV: write -f u-boot-mfgtool.itb
          SDPV: jump
          
          FB: ucmd setenv fastboot_dev mmc
          FB: ucmd setenv mmcdev \${emmc_dev}
          FB: ucmd mmc dev \${emmc_dev} 1; mmc erase 0 0x2000
          FB: flash -raw2sparse all lmp-factory-image-$MACHINE.wic.gz/*
          FB: flash bootloader imx-boot-$MACHINE
          FB: flash bootloader2 u-boot-$MACHINE.itb
          FB: flash bootloader_s imx-boot-$MACHINE
          FB: flash bootloader2_s u-boot-$MACHINE.itb
          FB: ucmd if env exists emmc_ack; then ; else setenv emmc_ack 0; fi;
          FB: ucmd mmc partconf \${emmc_dev} \${emmc_ack} 1 0
          FB: done
          UUU_EOF
          
          echo "‚úÖ Created UUU script: program_$MACHINE.uuu"
          echo ""
          echo "üîå To program the board:"
          echo "  1. Put board in download mode"
          echo "  2. Connect USB cable"
          echo "  3. Run: sudo uuu program_$MACHINE.uuu"
          echo ""
          echo "Or use this script with --flash to program automatically:"
          echo "  ./program-$MACHINE.sh --flash"
          
          # Optionally run UUU if requested
          if [ "${1:-}" = "--flash" ]; then
              echo "üöÄ Starting board programming..."
              if command -v uuu >/dev/null 2>&1; then
                  sudo uuu "program_$MACHINE.uuu"
              else
                  echo "‚ùå UUU tool not found. Please install NXP UUU tool first."
                  exit 1
              fi
          fi
          EOF
          
          chmod +x programming-packages/${{ matrix.machine }}/program-${{ matrix.machine }}.sh
          
          # Create comprehensive step-by-step README
          cat > programming-packages/${{ matrix.machine }}/README.md << 'EOF'
          # üöÄ Board Programming Guide: ${{ matrix.machine }}
          
          > **Complete step-by-step instructions for programming your Dynamic Devices board**
          
          **Generated**: $(date)  
          **Commit**: ${{ github.sha }}  
          **Branch**: ${{ github.ref_name }}  
          **Build**: ${{ github.run_number }}
          
          ## üì¶ What's In This Package
          
          This programming package contains everything needed to flash your board:
          
          ### üîß Manufacturing Tools
          - `imx-boot-mfgtool` - Special bootloader for programming mode
          - `u-boot-mfgtool.itb` - Programming U-Boot environment
          
          ### üíæ Production Firmware  
          - `imx-boot-${{ matrix.machine }}` - Your board's production bootloader
          - `u-boot-${{ matrix.machine }}.itb` - Your board's production U-Boot
          - `lmp-factory-image-${{ matrix.machine }}.wic.gz` - Complete Linux system image
          
          ### üõ†Ô∏è Programming Scripts
          - `program-${{ matrix.machine }}.sh` - **START HERE** - Automated programming script
          - `program_${{ matrix.machine }}.uuu` - Low-level UUU commands (auto-generated)
          
          ### üìã Security & Compliance
          - `sbom.json` - Software Bill of Materials (SPDX format)
          - `*.manifest` - Package manifest files for traceability
          
          ---
          
          ## ‚ö° Quick Start (5 Minutes)
          
          ### **Step 1: Install UUU Tool** üì•
          
          #### Option A: Package Manager (Recommended)
          ```bash
          # Ubuntu/Debian
          sudo apt update && sudo apt install uuu
          
          # Fedora/CentOS/RHEL
          sudo dnf install uuu
          
          # Arch Linux
          sudo pacman -S uuu
          ```
          
          #### Option B: Direct Download
          ```bash
          # Download latest UUU
          wget https://github.com/nxp-imx/mfgtools/releases/latest/download/uuu
          chmod +x uuu
          sudo mv uuu /usr/local/bin/
          
          # Verify installation
          uuu --help
          ```
          
          ### **Step 2: Prepare Your Board** üîå
          
          #### **Physical Setup:**
          1. **Power OFF** your board completely
          2. **Locate boot switches** on your board (usually near USB connector)
          3. **Set to download mode**:
             - Consult your board manual for exact switch positions
             - Typically involves setting specific DIP switches or jumpers
          4. **Connect USB cable** from board to your computer
          5. **Power ON** your board
          
          #### **Verify Download Mode:**
          ```bash
          # Check if board is detected
          lsusb | grep -i "NXP\|Freescale"
          
          # Should show something like:
          # Bus 001 Device 005: ID 1fc9:012f NXP Semiconductors
          ```
          
          ### **Step 3: Program Your Board** ‚ö°
          
          #### **Automated Programming (Easiest):**
          ```bash
          # Navigate to this directory
          cd programming-package-${{ matrix.machine }}/
          
          # Make script executable (if needed)
          chmod +x program-${{ matrix.machine }}.sh
          
          # Program the board (takes 3-5 minutes)
          ./program-${{ matrix.machine }}.sh --flash
          ```
          
          #### **Manual Programming (Advanced):**
          ```bash
          # Use UUU directly
          sudo uuu program_${{ matrix.machine }}.uuu
          ```
          
          ### **Step 4: First Boot** üéâ
          
          1. **Programming complete** - Wait for "Programming successful" message
          2. **Power OFF** the board
          3. **Set switches back** to normal boot mode (consult board manual)
          4. **Power ON** the board
          5. **Wait 30-60 seconds** for first boot (may take longer initially)
          6. **Connect via serial** or **SSH** to access your board
          
          ---
          
          ## üéØ Board-Specific Information
          
          ### **Board Details:**
          - **Machine**: ${{ matrix.machine }}
          - **Architecture**: $(echo "${{ matrix.machine }}" | grep -q "imx8mm" && echo "i.MX8M Mini (Cortex-A53)" || echo "i.MX93 (Cortex-A55)")
          - **Board Type**: $(echo "${{ matrix.machine }}" | sed 's/.*jaguar-//' | tr '[:lower:]' '[:upper:]')
          - **Flash Memory**: eMMC internal storage
          
          ### **What Gets Programmed:**
          1. **Bootloader** - Low-level boot code
          2. **U-Boot** - Boot environment and configuration  
          3. **Linux Kernel** - Operating system kernel
          4. **Root Filesystem** - Complete Linux system with applications
          
          ---
          
          ## ‚ö†Ô∏è Troubleshooting
          
          ### **Board Not Detected**
          
          **Problem**: `lsusb` doesn't show NXP device
          
          **Solutions**:
          - ‚úÖ Verify USB cable is data cable (not power-only)
          - ‚úÖ Try different USB port on your computer
          - ‚úÖ Check boot switches are in correct download position
          - ‚úÖ Power cycle the board (off/on)
          - ‚úÖ Check board manual for exact switch positions
          
          ### **Programming Fails**
          
          **Problem**: UUU shows errors or timeouts
          
          **Solutions**:
          - ‚úÖ Run with `sudo` privileges: `sudo ./program-${{ matrix.machine }}.sh --flash`
          - ‚úÖ Verify all files are present: `ls -la *.gz *.itb imx-boot-*`
          - ‚úÖ Check UUU version: `uuu --version` (should be 1.4.0+)
          - ‚úÖ Try manual programming: `sudo uuu program_${{ matrix.machine }}.uuu`
          - ‚úÖ Check USB connection stability
          
          ### **Board Won't Boot After Programming**
          
          **Problem**: Board doesn't start after programming
          
          **Solutions**:
          - ‚úÖ **Check boot switches** - Must be in NORMAL boot mode (not download mode)
          - ‚úÖ **Power cycle** the board completely
          - ‚úÖ **Wait longer** - First boot can take 2-3 minutes
          - ‚úÖ **Check serial console** for boot messages
          - ‚úÖ **Re-program** if needed (board should still be recoverable)
          
          ### **Permissions Errors**
          
          **Problem**: "Permission denied" when accessing USB device
          
          **Solutions**:
          ```bash
          # Add yourself to dialout group
          sudo usermod -a -G dialout $USER
          
          # Or run with sudo
          sudo ./program-${{ matrix.machine }}.sh --flash
          
          # Log out and back in for group changes to take effect
          ```
          
          ---
          
          ## üîß Advanced Usage
          
          ### **Verify Programming Before Boot**
          ```bash
          # Check all required files are present
          ls -la imx-boot-* u-boot-* *.wic.gz
          
          # Verify file sizes (should not be 0 bytes)
          du -h *
          ```
          
          ### **Custom UUU Commands**
          ```bash
          # View the UUU script that will be executed
          cat program_${{ matrix.machine }}.uuu
          
          # Run individual UUU commands for debugging
          sudo uuu -v program_${{ matrix.machine }}.uuu
          ```
          
          ### **Recovery Mode**
          If your board becomes unbootable, you can always recover by:
          1. Putting board back in download mode
          2. Re-running the programming process
          3. The board should always be recoverable via this method
          
          ---
          
          ## üìû Support
          
          ### **Documentation**
          - **Board Wiki**: https://github.com/DynamicDevices/meta-dynamicdevices/wiki
          - **Troubleshooting**: https://github.com/DynamicDevices/meta-dynamicdevices/wiki/Troubleshooting
          
          ### **Need Help?**
          - **GitHub Issues**: https://github.com/DynamicDevices/meta-dynamicdevices/issues
          - **Email Support**: support@dynamicdevices.co.uk
          
          ### **Professional Services**
          For custom development, integration support, or commercial licensing:
          - **Contact**: licensing@dynamicdevices.co.uk
          - **Website**: https://dynamicdevices.co.uk
          
          ---
          
          **‚úÖ Programming successful? Your board should now boot to a fully functional Linux system with networking, containers, and development tools ready!**
          
          EOF

      - name: Upload complete programming package
        uses: actions/upload-artifact@v4
        with:
          name: programming-package-${{ matrix.machine }}
          path: programming-packages/${{ matrix.machine }}/
          retention-days: 90
          if-no-files-found: warn

  # Summary job that creates overall build status
  summary:
    runs-on: self-hosted
    needs: [setup, build, create-programming-packages]
    if: always() && needs.setup.outputs.should_build == 'true'
    steps:
      - name: Generate build summary
        run: |
          echo "# KAS Build CI Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Workflow:** ${{ github.workflow }}" >> $GITHUB_STEP_SUMMARY
          echo "**Trigger:** ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "**Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Determine overall status
          if [ "${{ needs.build.result }}" = "success" ]; then
            echo "## ‚úÖ Build Status: SUCCESS" >> $GITHUB_STEP_SUMMARY
            echo "All builds completed successfully!" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ needs.build.result }}" = "failure" ]; then
            echo "## ‚ùå Build Status: FAILURE" >> $GITHUB_STEP_SUMMARY
            echo "One or more builds failed. Check individual job logs for details." >> $GITHUB_STEP_SUMMARY
          else
            echo "## ‚ö†Ô∏è Build Status: ${{ needs.build.result }}" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Build Matrix" >> $GITHUB_STEP_SUMMARY
          echo "Machines built: ${{ needs.setup.outputs.machines }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Artifacts" >> $GITHUB_STEP_SUMMARY
          echo "Build artifacts and reports are available in the workflow artifacts section." >> $GITHUB_STEP_SUMMARY

      - name: Update issue status
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        run: |
          echo "Updating GitHub issue #14 with CI status"
          # This would update the issue, but requires GitHub token with appropriate permissions
          # For now, just log the intent
          echo "CI build completed with status: ${{ needs.build.result }}"
